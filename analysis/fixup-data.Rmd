---
title: "Preprocessing Data for Estimates of Realized Response to Selection in *Chamaecrista fasciculata* and Decomposition into Environmental and Genetic Parts"
author:
  - "Mason W. Kulbaba^[St. Mary's University, mason.kulbaba@stmu.ca, https://orcid.org/0000-0003-0619-7089]"
  - "Seema N. Sheth^[Department of Plant and Microbial Biology, North Carolina State University, ssheth3@ncsu.edu, https://orcid.org/0000-0001-8284-7608]"
  - "Rachel E. Pain^[Ecology, Evolution and Behavior Graduate Program, University of Minnesota, repain@umn.edu]"
  - "Vincent M. Eckhart^[Department of Biology, Grinnell College, eckhart@grinnell.edu]"
  - "Charles J. Geyer^[School of Statistics, University of Minnesota, geyer@umn.edu, https://orcid.org/0000-0003-1471-1703]"
  - "Ruth G. Shaw^[Department of Ecology, Evolution and Behavior, University of Minnesota, shawx016@umn.edu, https://orcid.org/0000-0001-5980-9291]"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

The git repository for these analyses is
https://github.com/cjgeyer/mf.
This repo is not currently public.

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

 * The version of the `knitr` package used to make this document is
   `r packageVersion("knitr")`.

# Data

## Data Files

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
knitr::opts_chunk$set(error=TRUE)
```

For the analyses here. the data files are
```{r data.files}
files <- list.files(pattern = "*.csv")
files
```
where

 * CS indicates Conard Environmental Research Area (CERA),

 * GC indicates Grey Cloud Dunes Scientific and Natural Area, and

 * KW indicates Kellogg-Weaver Dunes, also called McCarthy Lake,

respectively.  These files include the same data on the same individuals
as in the data files used by @kulbaba-et-al and @zenodo but also include
more individuals, who are offspring of those analyzed before.
For more details, see @kulbaba-et-al
and Section \@ref(rationalize-cohort-labels) below.

As can be seen, we have three kinds of files.

 * Those without `"planting"` in their names are the primary data
   files for the three sites.

 * Those with `"planting_data"` in their names are secondary data files
   used to obtain pedigree information for some analyses.

 * The one with `"planting.data"` in its name is a similar secondary
   data file that we will actually not need to use (but can use for checks).

Distinguish these file types.
```{r distinguish}
files.planting <- grep("planting_data", files, value = TRUE)
files.primary <- grep("planting", files, value = TRUE, invert = TRUE)
files.secondary <- files |> setdiff(files.planting) |> setdiff(files.primary)
files.primary
files.planting
files.secondary
```

Read in some of these files.
```{r read.data}
data.primary <- lapply(files.primary, read.csv)
data.planting <- lapply(files.planting, read.csv)
names(data.primary) <- substr(files.primary, 1, 2) |> toupper()
names(data.primary)
names(data.planting) <- substr(files.planting, 1, 2)
names(data.planting)
```

## NA Cohort Labels

The variable `cohort` in these data frames tells us what generation
the data are.

  * `cohort == "greenhouse"` is the first generation planted.  These
    are pedigreed crosses: both mother and father are known.

  * `cohort %in% c("field", "G2YR2", "G2YR3")` is the second generation
    planted.  These are open pollinated: mother is known, father is unknown.

  * `cohort == "G3YR2"` is the third generation planted.  We do not analyze
    these data in this analysis.

But some individuals are not labeled as to cohort.
```{r show.na.cohort}
sapply(data.primary, function(x) with(x, sum(is.na(cohort))))
```

What do these individuals look like?
```{r show.na.cohort.too}
lapply(data.primary, function(x) subset(x, is.na(cohort)))
```

Delete them.
```{r delete.na.cohort}
data.primary <- lapply(data.primary, function(x) subset(x, ! is.na(cohort)))
```

## Rationalize Cohort Labels

As we said above, these data have a variable `cohort` that is inconsistent
among sites.
```{r show.cohort}
lapply(data.primary, function(x) with(x, split(year, cohort)) |> lapply(unique))
```

 * In site KW, all offspring individuals are labeled as cohort `"field"`.

 * In site CS, offspring in 2016 are labeled as cohort `"field"` and those
   in 2017 are labeled as cohort `"G2YR3"` for generation 2 year 3
   apparently because 2017 is the third year of the whole experiment.

 * In site GC, offspring in 2016 are labeled as cohort `"field"` and those
   in 2017 are labeled as cohort `"G2YR2"` for generation 2 year 2
   apparently because 2017 is the second year of the experiment *in which
   offspring were planted*.

 * In site GC, there are also offspring of offspring labeled as cohort
   `"G3YR2"` for generation 3 year 2.  We do not analyze these individuals
   in this analysis.  So we omit them from the output file.

Drop the `"G3YR2"` individuals from GC.
```{r fixup-cohort-subset}
data.primary <- lapply(data.primary, function(x) subset(x, cohort != "G3YR2"))
sapply(data.primary, function(x) unique(sort(x$cohort)))
```

Now convert `"G2YR2"` or `"G2YR3"` to "field".  These labels being
now totally redundant, telling us nothing the year does not also say.
In the following code chunk, `"G2YR[23]"` is a regular expression that
matches either `"G2YR2"` or `"G2YR3"`.
```{r fixup-cohort-labels}
data.primary <- lapply(data.primary, transform, cohort.orig = cohort,
    paternalID.orig = paternalID, maternalID.orig = maternalID) # DEBUG
data.primary <- lapply(data.primary,
    function(x) transform(x, cohort = sub("G2YR[23]", "field", cohort)))
lapply(data.primary, function(x) unique(sort(x$cohort)))
sapply(data.primary, function(x) with(x, is.na(cohort)) |> sum())
```

Now `cohort` is consistent between sites.

## Convert Parental ID Zero to NA

Parental ID Zero indicates "unknown" and hence should be converted
to `NA` to be more R-ish.
```{r zero-to-na}
data.primary <- lapply(data.primary, function(x) transform(x,
    paternalID = ifelse(paternalID == 0, NA_integer_, paternalID),
    maternalID = ifelse(maternalID == 0, NA_integer_, maternalID)))
```

## Remove Individuals with Unknown Parents

For individuals in the `"greenhouse"` cohort, which were pedigreed crosses,
we should have both parents recorded.  Check this.
```{r na-delete-greenhouse}
sapply(data.primary, function(x) with(x, cohort == "greenhouse" &
    (is.na(paternalID) | is.na(maternalID))) |> sum())
sapply(data.primary, function(x) with(x, cohort == "greenhouse" &
    is.na(paternalID)) |> sum())
```
Remove these individuals.
```{r na-delete-greenhouse-doit}
sapply(data.primary, nrow)
data.primary <- lapply(data.primary, function(x) subset(x,
    ! (cohort == "greenhouse" & is.na(paternalID))))
sapply(data.primary, nrow)
```

For individuals in the `"field"` cohort, which were open pollinated, sires
are unknown and this is not a problem but rather by design.  So we
only remove individuals with sire unknown that are not in cohort `"field"`.
We do however need to remove individuals whose mothers are unknown.  Check this.
```{r na-delete-field}
sapply(data.primary, function(x) with(x,
    cohort == "field" & is.na(maternalID)) |> sum())
```

And do the removal.
```{r na-delete-field-doit}
sapply(data.primary, nrow)
data.primary <- lapply(data.primary, function(x) subset(x,
    ! (cohort == "field" & is.na(maternalID))))
sapply(data.primary, nrow)
```

## Check for Data Inconsistencies

The aster graph for these data is
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the node labels correspond to variable names in the data frames
and the arrow labels correspond to conditional distributions.  Thus all
of these variables must be nonnegative-integer-valued.
```{r check.integer}
data.primary |> lapply(function(x)
    x[c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")]) |>
    lapply(function(x) sapply(x, function(x) is.integer(x) & all(x >= 0)))
```

Then we must also have
```{r check.constraint}
sapply(data.primary, function(x) with(x, all(Germ <= 1)))
sapply(data.primary, function(x) with(x, all(flw <= Germ)))
sapply(data.primary, function(x)
    with(x, all(total.pods.collected <= total.pods)))
```
So this last check fails.
We will repair in the following section
(Section \@ref(fix-data-inconsistencies)).

In the following block, `(`some logical expression`) <= (`some other logical
expression`)` is an R-ism for the [material implication operator](https://en.wikipedia.org/wiki/Material_conditional), that is, left-hand logical expression
implies right-hand logical expression (if the former is true, then the latter
is true).  This works because the logical expressions are converted
to zero-or-one expressions to be compared with `<=`.  The parentheses are
necessary because of R's operator precedence.
```{r check.constraint-too}
sapply(data.primary, function(x)
    with(x, all((Germ == 0) <= (flw == 0))))
sapply(data.primary, function(x)
    with(x, all((flw == 0) <= (total.pods == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods == 0) <= (total.pods.collected == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods.collected == 0) <= (totalseeds == 0))))
```
So all of these checks pass.

How many individuals have problems?
```{r consistency.check.how.many}
lapply(data.primary, function(x)
    subset(x, total.pods.collected > total.pods)[c("total.pods", "total.pods.collected")])
```

## Fix Data Inconsistencies

So we need to fix up these inconsistencies.
```{r consistency.fixup}
data.primary <- lapply(data.primary, function(x)
    transform(x, total.pods.collected = pmin(total.pods, total.pods.collected)))
```
And recheck.
```{r check.constraint.again}
<<check.constraint>>
<<check.constraint-too>>
```
OK.

# Find Grandfathers

## Introduction

For the `"field"` cohort, we need to find maternal grandfathers (fathers are
unknown).  This is a complicated process, made even more complicated by having
to do this three different ways.

### Method 1 (Only for GC Data)

If the dataset has a `positionID` variable, then this identifies
individuals in the same way that `paternalID` and `maternalID` do,
that is, if `x` is the data frame
```{r method1-data}
site <- "GC"
x <- data.primary[[site]]
```
then
```{r method1-idx}
idx <- with(x, match(maternalID, positionID))
```
finds the row indices of mothers of individuals, hence
```{r method1-gramps}
gramps <- with(x, paternalID[idx])
```
finds grandfathers.  Check that this worked
```{r method1-check}
with(x, (cohort == "field") <= (! is.na(gramps))) |> all()
```

Store grandfathers for these data.
```{r store-grandfathers}
data.primary[[site]] <- transform(x, grandpaternalID = gramps)
```

### Method 2 (Only for CS and KW Data and Only for 2017)

```{r method2-data}
site <- "CS"
x <- data.primary[[site]]
```
For some individuals `paternalID` (which should be 0 for unknown) the
grandpaternal ID is actually stored in `paternalID`.  This only makes
sense for individuals with `cohort == "field"` of course (for other
individuals paternal ID means paternal ID.

```{r method2-gramps}
gramps <- with(x, paternalID)
gramps[x$cohort != "field"] <- NA_integer_
```

Check that this worked.
```{r method2-check}
with(x, (cohort == "field" & year == 2017) <= (! is.na(gramps))) |> all()
```

### Method 3 (Only for CS and KW Data and Only for 2016)

Still using the same data but now we need both primary and secondary data.
```{r method3-data}
site
x <- data.primary[[site]]
y <- data.planting[[site]]
```
Now individuals are found by `row` and `position` in both data sets.  So
```{r method3-planting}
key.indiv <- with(x, paste(row, position, sep = ":"))
key.plant <- with(y, paste(row, position, sep = ":"))
idx <- match(key.indiv, key.plant)
```
Now `idx[i]` is the row index in the planting data file of the individual
that has row index `i` in the primary data file. And
```{r method3-mothers}
key.moms <- with(y, paste(maternalrow, maternalposition, sep = ":"))
idx.moms <- match(key.moms[idx], key.indiv)
```
Now `idx.moms[i]` is the row index in the primary data file of the
the mother of the individual
that has row index `i` in the primary data file. And
```{r method3-gramps}
gramps.too <- with(x, paternalID[idx.moms])
gramps.too[x$cohort != "field"] <- NA
```
looks up the fathers of those mothers.

Check that this worked.
```{r method3-check}
with(x, (cohort == "field" & year == 2016) <= (! is.na(gramps.too))) |> all()
```

Store grandfathers for these data.
```{r store-grandfathers-too}
data.primary[[site]] <- transform(x,
    grandpaternalID = ifelse(year == 2017, gramps, gramps.too))
```

## Redo Methods 2 and 3 for Other Site

The following code chunk extensively quotes code chunks above,
but you have to look at the R markdown source to see that.
```{r method3-data-too}
site <- "KW"
x <- data.primary[[site]]
y <- data.planting[[site]]
# method 2
<<method2-gramps>>
# method 3
<<method3-planting>>
<<method3-mothers>>
<<method2-check>>
<<method3-gramps>>
<<method3-check>>
# both methods
<<store-grandfathers-too>>
```

# Make Numerical Variables Categorical

Parental ID variables and `block` are numeric (integer).  But statistically
they are categorical.  So we must make them type `factor` so R will treat
them correctly.
```{r to.factor}
data.primary <- lapply(data.primary, function(x)
    transform(x, maternalID = as.factor(maternalID),
    paternalID = as.factor(paternalID),
    grandpaternalID = as.factor(grandpaternalID),
    block = as.factor(block)))
```

# One More Data Inconsistency to Deal With

```{r planting}
sites <- names(data.primary)
sites
years <- with(data.primary[[1]], year[cohort == "field"] |> sort() |> unique())
years
```

It is a scientific inconsistency that parents had viable seeds but no
seeds were planted.  We need to deal with that.  How large is the problem.
```{r planting.too}
foo <- list()
for (site in sites) {
    x <- data.primary[[site]]
    my.result <- NULL
    for (year in years) {
        year.before <- as.character(as.numeric(year) - 1)
        x.prev <- subset(x, cohort == "greenhouse" & year == year.before)
        x.off <- subset(x, cohort == "field" & year == year)
        pas <- x.prev$paternalID
        grampas <- x.off$grandpaternalID
        oopsie <- setdiff(pas, grampas)
        result <- x.prev$totalseeds
        names(result) <- pas
        result <- result[names(result) %in% oopsie]
        result <- split(result, names(result))
        result <- sapply(result, sum)
        if (length(result) == 0) result <- double(0)
        result <- result[order(as.numeric(names(result)))]
        foo[[site]][[year.before]] <- result
    }
}
foo
```
In the code chunk above R object `foo` gives total seed counts for `paternalID`
for which no seeds were planted in the following year.
This seems unproblematic for sites `CS` and `KW` but seems hard to explain
for site `GC`.  Why were no seeds planted when hundreds of viable seeds
were recorded?

Also why exactly the same both years?   Shouldn't this be random?
```{r same-o-same-o}
all(names(foo$GS[["2015"]]) == names(foo$GS[["2015"]]))
all(names(foo$KW[["2015"]]) == names(foo$KW[["2015"]]))
```

# Check Agreement with Old Analyses

Check that these agree with old analyses.
```{r check.with.old}
load("KW_subdatfield.rda")
old <- with(subdatfield, grandfather)
new <- with(data.primary$KW, grandpaternalID[cohort == "field" & year == 2016])
identical(as.character(old), as.character(new))
load("GC_subdatfield.rda")
old <- with(subdatfield, grandfather)
new <- with(data.primary$GC, grandpaternalID[cohort == "field" & year == 2016])
identical(as.character(old), as.character(new))
```

# Tidy Data

One more thing to do.
```{r untidy}
lapply(data.primary, names)
common.names <- lapply(data.primary, names) |> Reduce(intersect, x = _)
common.names
data.primary <- lapply(data.primary, function(x) x[common.names])
```

# Write Out Data

```{r write}
save(data.primary, file = "mf.rda")
```

# References
