---
title: "Preprocessing Data for Estimates of Realized Response to Selection in *Chamaecrista fasciculata* and Decomposition into Environmental and Genetic Parts"
author:
  - "Mason W. Kulbaba^[St. Mary's University, mason.kulbaba@stmu.ca, https://orcid.org/0000-0003-0619-7089]"
  - "Seema N. Sheth^[Department of Plant and Microbial Biology, North Carolina State University, ssheth3@ncsu.edu, https://orcid.org/0000-0001-8284-7608]"
  - "Rachel E. Pain^[Ecology, Evolution and Behavior Graduate Program, University of Minnesota, repain@umn.edu]"
  - "Vincent M. Eckhart^[Department of Biology, Grinnell College, eckhart@grinnell.edu]"
  - "Charles J. Geyer^[School of Statistics, University of Minnesota, geyer@umn.edu, https://orcid.org/0000-0003-1471-1703]"
  - "Ruth G. Shaw^[Department of Ecology, Evolution and Behavior, University of Minnesota, shawx016@umn.edu, https://orcid.org/0000-0001-5980-9291]"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

The git repository for these analyses is
https://github.com/cjgeyer/mf.
This repo is not currently public.

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

# Data

## Get It

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
# knitr::opts_chunk$set(error=TRUE)
```

For the analyses here. the data files are
```{r data.files}
files <- list.files(pattern = "*.csv")
files
```
for 

 * Conard Environmental Research Area (CERA),

 * Grey Cloud Dunes Scientific and Natural Area, and

 * Kellogg-Weaver Dunes, also called McCarthy Lake,

respectively.  These files include the same data on the same individuals
as in the data files used by @kulbaba-et-al and @zenodo but also include
more individuals, who are offspring of those analyzed before.
For more details, see @kulbaba-et-al.

As can be seen, we have three kinds of files.

 * Those without `"planting"` in their names are the primary data
   files for the three sites.

 * Those with `"planting_data"` in their names are secondary data files
   used to obtain pedigree information for some analyses.

 * The one with `"planting.data"` in its name is a similar secondary
   data file that we will actually not need to use (but can use for checks).

Distinguish these file types.
```{r distinguish}
files.planting <- grep("planting_data", files, value = TRUE)
files.primary <- grep("planting", files, value = TRUE, invert = TRUE)
files.secondary <- files |> setdiff(files.planting) |> setdiff(files.primary)
files.primary
files.planting
files.secondary
```

Read in these files.
```{r read.data}
data.primary <- lapply(files.primary, read.csv)
data.planting <- lapply(files.planting, read.csv)
names(data.primary) <- substr(files.primary, 1, 2) |> toupper()
names(data.primary)
names(data.planting) <- substr(files.planting, 1, 2)
names(data.planting)
```

## Remove Parental ID Zero

Parental ID Zero indicates "unknown" and hence should be removed from
these analyses.   We have to do this carefully because
```{r show.cohort}
lapply(data.primary, function(x) sort(unique(x$cohort)))
```
for individuals in the `"field"` cohort, which were open pollinated, sires
are unknown and this is not a problem but rather by design.  So we
only remove individuals with sire unknown that are not in cohort `"field"`.

Check how many we are going to remove.  Since operator precedence in R
is from highest to lowest `==` and `!=` (same level) then `&` and then `|`,
the following does do what is wanted.
```{r check.parental.zero}
sapply(data.primary, function(x)
    sum(with(x, maternalID == 0 | cohort != "field" & paternalID == 0)))
```
And do the removal.
```{r remove.parental.zero}
data.primary <- lapply(data.primary, function(x)
    subset(x, ! (maternalID == 0 | cohort != "field" & paternalID == 0)))
```

## Make Numerical Variables Categorical

Parental ID variables and `block` are numeric (integer).  But statistically
they are categorical.  So we must make them type `factor` so R will treat
them correctly.
```{r to.factor}
data.primary <- lapply(data.primary, function(x)
    transform(x, maternalID = as.factor(maternalID),
    paternalID = as.factor(paternalID), block = as.factor(block)))
```

## Check for Data Inconsistencies

The aster graph for these data is
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the node labels correspond to variable names in the data frames
and the arrow labels correspond to conditional distributions.  Thus all
of these variables must be nonnegative-integer-valued.
```{r check.integer}
data.primary |> lapply(function(x)
    x[c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")]) |>
    lapply(function(x) sapply(x, function(x) is.integer(x) & all(x >= 0)))
```

Then we must also have
```{r check.constraint}
sapply(data.primary, function(x) with(x, all(Germ <= 1)))
sapply(data.primary, function(x) with(x, all(flw <= Germ)))
sapply(data.primary, function(x)
    with(x, all(total.pods.collected <= total.pods)))
```
So this last check fails.
We will repair in the following section
(Section \@ref(fix-data-inconsistencies)).

In the following block, `(`some logical expression`) <= (`some other logical
expression`)` is an R-ism for the [material implication operator](https://en.wikipedia.org/wiki/Material_conditional), that is, left-hand logical expression
implies right-hand logical expression (if the former is true, then the latter
is true).  This works because the logical expressions are converted
to zero-or-one expressions to be compared with `<=`.  The parentheses are
necessary because of R's operator precedence.
```{r check.constraint-too}
sapply(data.primary, function(x)
    with(x, all((Germ == 0) <= (flw == 0))))
sapply(data.primary, function(x)
    with(x, all((flw == 0) <= (total.pods == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods == 0) <= (total.pods.collected == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods.collected == 0) <= (totalseeds == 0))))
```
So all of these checks pass.

How many individuals have problems?
```{r consistency.check.how.many}
lapply(data.primary, function(x)
    subset(x, total.pods.collected > total.pods)[c("total.pods", "total.pods.collected")])
```

## Fix Data Inconsistencies

So we need to fix up these inconsistencies.
```{r consistency.fixup}
data.primary <- lapply(data.primary, function(x)
    transform(x, total.pods.collected = pmin(total.pods, total.pods.collected)))
```
And recheck.
```{r check.constraint.again}
<<check.constraint>>
<<check.constraint-too>>
```
OK.

# Find Grandfathers

## Introduction

For the `"field"` cohort, we need to find maternal grandfathers (fathers are
unknown).  This is a complicated process, made even more complicated by having
to do this three different ways for the three different data sets.

In order for parts of these examples to be easily repeatable, we follow the
DRY/SPOT rule (Wikipedia articles
[Don't Repeat Yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself)
and
[Single Point of Truth](https://en.wikipedia.org/wiki/Single_source_of_truth))
and define a variable
```{r dry.spot}
site <- "GC"
```
that says which data set we are working on.

## The GC Data

```{r particular.gc}
foo <- data.primary[[site]]
names(foo)
```
For these data, `positionID` is the ID of the individual
(row of the data frame), and `maternalID` is the ID of the maternal plant.
So the grandfather is the `paternalID` of this maternal plant.
```{r keys-gc}
foobar <- with(foo, match(maternalID, positionID))
```
R object `foobar` is now the index (row number) of the mother of the
corresponding individual, that is, the individual in row `i` has their
mother in row `foobar[i]`.  Hence the father of that mother has ID
`foo$paternalID[foobar]`.
```{r grandsires}
data.primary[[site]] <- transform(data.primary[[site]],
    grandpaternalID = paternalID[foobar])
```

## The CS Data

For the other two data sets we do something completely different
(and, partially, different from each other).
Reset the DRY/SPOT variable
```{r dry.spot-too}
site <- "CS"
```
And the data frames (both of them) are
```{r particular}
foo <- data.primary[[site]]
bar <- data.planting[[site]]
```
```{r particular-too}
names(foo)
names(bar)
```
Variables `"row"` and `"position"` tell where an individual is
(in both data frames).
Variables `"maternalrow"` and `"maternalposition"` tell where the mother
of the corresponding individual is.
R function `match` allows us to match
these up, but needs single things to match.  So we paste row and position
together to make one "key".
In the check, `<=` is again the [material implication
operator](https://en.wikipedia.org/wiki/Material_conditional).
```{r keys}
foo.key <- with(foo, paste(row, position, sep = ":"))
bar.key <- with(bar, paste(row, position, sep = ":"))
baz.key <- with(bar, paste(maternalrow, maternalposition, sep = ":"))
sort(foo.key) |> head()
sort(bar.key) |> head()
foobar <- match(foo.key, bar.key)
all((foo$cohort == "field") <= (! is.na(foobar)))
```
R object `foobar` is now a vector whose length is the row dimension
of data frame `foo` (which is `data.primary[[site]]`) and whose
values (if not `NA`)
give the row index of the corresponding individual in data frame `bar`
(which is `data.planting[[site]]`).

So far, so good.  Now we look up the maternal position.
```{r keys-too}
qux.key <- baz.key[foobar]
all((foo$cohort == "field") <= (! is.na(qux.key)))
```

Then we find those mothers.
```{r keys-too-too}
fooqux <- match(qux.key, foo.key)
```

And finally, we find the fathers of those mothers.
```{r keys-too-too-too}
data.primary[[site]] <- transform(data.primary[[site]],
    grandpaternalID = paternalID[fooqux])
with(data.primary[[site]],
    all((cohort == "field") <= (! is.na(grandpaternalID))))
```

We check that we indeed did what we intended to do.  Find a random
`"field"` individual.
```{r random.field}
i <- sample(which(with(foo, cohort == "field")), 1)
foo[i, ]
bar[foobar[i], ]
foo[fooqux[i], ]
data.primary[[site]]$grandpaternalID[i]
stopifnot(foo[i, "row"] == bar[foobar[i], "row.1"])
stopifnot(foo[i, "position"] == bar[foobar[i], "position.1"])
stopifnot(bar[foobar[i], "maternalrow"] == foo[fooqux[i], "row"])
stopifnot(bar[foobar[i], "maternalposition"] == foo[fooqux[i], "position"])
stopifnot(foo[fooqux[i], "paternalID"] ==
    data.primary[[site]]$grandpaternalID[i])
```
Everything checks (note that because we did not set a random seed, this
checks for a different random individual every time the file is processed).

## The KW Data

Now we do exactly the same thing for
```{r dry.spot-too-too}
site <- "KW"
```
Do it.
```{r redo}
<<particular>>
<<keys>>
<<keys-too>>
<<keys-too-too>>
gramps <- with(data.primary[[site]], paternalID[fooqux])
all((foo$cohort == "field") <= (! is.na(gramps)))
```

This does not work.  Site KW is not like site CS.
Find out where the problems are.
```{r find.out}
with(foo, year[foo$cohort == "field" & is.na(gramps)]) |> unique()
with(foo, year[foo$cohort == "field" & (! is.na(gramps))]) |> unique()
```

It turns out that the grandfathers we have failed to find with the code
above, are actually in the `paternalID` field for these individuals, that is,
"paternal" here means maternal grandfathers (which are known) rather than
fathers (which are unknown).
```{r find.out.too}
all(with(foo, paternalID[cohort == "field" & is.na(gramps)]) != 0)
gramps[foo$cohort == "field" & foo$year == 2017] <-
    foo$paternalID[foo$cohort == "field" & foo$year == 2017]
all((foo$cohort == "field") <= (! is.na(gramps)))
```
Looks OK.
```{r kw.gramps}
data.primary[[site]]$grandpaternalID <- gramps
```

# Check Agreement with Old Analyses

Check that these agree with old analyses.
```{r check.with.old}
load("KW_subdatfield.rda")
old <- with(subdatfield, grandfather)
new <- with(data.primary$KW, grandpaternalID[cohort == "field" & year == 2016])
identical(as.character(old), as.character(new))
load("GC_subdatfield.rda")
old <- with(subdatfield, grandfather)
new <- with(data.primary$GC, grandpaternalID[cohort == "field" & year == 2016])
identical(as.character(old), as.character(new))
```

# Check Agreement with Secondary Data File

```{r secondary.names}
site
foo <- data.primary[[site]]
bar <- read.csv(files.secondary)
names(bar)
<<keys>>
all((foo$cohort == "field" & foo$year == 2017) <= (! is.na(foobar)))
<<keys-too>>
<<keys-too-too>>
all((foo$cohort == "field" & foo$year == 2017) <= (! is.na(qux.key)))
```
Now we repeat the checks we did above for the CS data.
Except now for a 2017 individual
```{r random.field.too}
i <- sample(which(with(foo, cohort == "field" & year == 2017)), 1)
foo[i, ]
bar[foobar[i], ]
foo[fooqux[i], ]
data.primary[[site]]$grandpaternalID[i]
stopifnot(foo[i, "row"] == bar[foobar[i], "row.1"])
stopifnot(foo[i, "position"] == bar[foobar[i], "position.1"])
stopifnot(bar[foobar[i], "maternalrow"] == foo[fooqux[i], "row"])
stopifnot(bar[foobar[i], "maternalposition"] == foo[fooqux[i], "position"])
stopifnot(foo[fooqux[i], "paternalID"] ==
    data.primary[[site]]$grandpaternalID[i])
```
So all of that checks too.

# Tidy Data

One more thing do too.
```{r untidy}
lapply(data.primary, names)
common.names <- lapply(data.primary, names) |> Reduce(intersect, x = _)
common.names
data.primary <- lapply(data.primary, function(x) x[common.names])
```

# Write Out Data

```{r write}
save(data.primary, file = "mf.rda")
```

# References
