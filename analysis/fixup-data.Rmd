---
title: "Preprocessing Data for Estimates of Realized Response to Selection in *Chamaecrista fasciculata* and Decomposition into Environmental and Genetic Parts"
author:
  - "Charles J. Geyer^[School of Statistics, University of Minnesota, geyer@umn.edu, https://orcid.org/0000-0003-1471-1703]"
  - "Mason W. Kulbaba^[St. Mary's University, mason.kulbaba@stmu.ca, https://orcid.org/0000-0003-0619-7089]"
  - "Seema N. Sheth^[Department of Plant and Microbial Biology, North Carolina State University, ssheth3@ncsu.edu, https://orcid.org/0000-0001-8284-7608]"
  - "Rachel E. Pain^[Ecology, Evolution and Behavior Graduate Program, University of Minnesota, repain@umn.edu]"
  - "Vincent M. Eckhart^[Department of Biology, Grinnell College, eckhart@grinnell.edu]"
  - "Ruth G. Shaw^[Department of Ecology, Evolution and Behavior, University of Minnesota, shawx016@umn.edu, https://orcid.org/0000-0001-5980-9291]"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

The git repository for these analyses is
https://github.com/cjgeyer/mf.
This repo is not currently public.

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

 * The version of the `knitr` package used to make this document is
   `r packageVersion("knitr")`.

# Data

## Data Files

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
knitr::opts_chunk$set(error=TRUE)
```

For the analyses here. the data files are
```{r data.files}
files <- list.files(pattern = "*.csv")
files
```
where

 * CS indicates Conard Environmental Research Area (CERA),

 * GC indicates Grey Cloud Dunes Scientific and Natural Area, and

 * KW indicates Kellogg-Weaver Dunes, also called McCarthy Lake,

respectively.  These files include the same data on the same individuals
as in the data files used by @kulbaba-et-al and @zenodo but also include
more individuals, who are offspring of those analyzed before.
For more details, see @kulbaba-et-al
and Section \@ref(rationalize-cohort-labels) below.

As can be seen, we have three kinds of files.

 * Those without `"planting"` in their names are the primary data
   files for the three sites.

 * Those with `"planting_data"` in their names are secondary data files
   used to obtain pedigree information for some analyses.

 * The one with `"planting.data"` in its name is a similar secondary
   data file that we will actually not need to use (but can use for checks).

Distinguish these file types.
```{r distinguish}
files.planting <- grep("planting_data", files, value = TRUE)
files.primary <- grep("planting", files, value = TRUE, invert = TRUE)
files.secondary <- files |> setdiff(files.planting) |> setdiff(files.primary)
files.primary
files.planting
files.secondary
```

Read in some of these files.
```{r read.data}
data.primary <- lapply(files.primary, read.csv)
data.planting <- lapply(files.planting, read.csv)
names(data.primary) <- substr(files.primary, 1, 2) |> toupper()
names(data.primary)
names(data.planting) <- substr(files.planting, 1, 2)
names(data.planting)
```

## NA Cohort Labels

The variable `cohort` in these data frames tells us what generation
the data are.

  * `cohort == "greenhouse"` is the first generation planted.  These
    are pedigreed crosses: both mother and father are known.

  * `cohort %in% c("field", "G2YR2", "G2YR3")` is the second generation
    planted.  These are open pollinated: mother is known, father is unknown.

  * `cohort == "G3YR2"` is the third generation planted.  We do not analyze
    these data in this analysis.

But some individuals are not labeled as to cohort.
```{r show.na.cohort}
sapply(data.primary, function(x) with(x, sum(is.na(cohort))))
```

What do these individuals look like?
```{r show.na.cohort.too}
lapply(data.primary, function(x) subset(x, is.na(cohort)))
```

Delete them.
```{r delete.na.cohort}
data.primary <- lapply(data.primary, function(x) subset(x, ! is.na(cohort)))
```

## Rationalize Cohort Labels

As we said above, these data have a variable `cohort` that is inconsistent
among sites.
```{r show.cohort}
lapply(data.primary, function(x) with(x, split(year, cohort)) |> lapply(unique))
```

 * In site KW, all offspring individuals are labeled as cohort `"field"`.

 * In site CS, offspring in 2016 are labeled as cohort `"field"` and those
   in 2017 are labeled as cohort `"G2YR3"` for generation 2 year 3
   apparently because 2017 is the third year of the whole experiment.

 * In site GC, offspring in 2016 are labeled as cohort `"field"` and those
   in 2017 are labeled as cohort `"G2YR2"` for generation 2 year 2
   apparently because 2017 is the second year of the experiment *in which
   offspring were planted*.

 * In site GC, there are also offspring of offspring labeled as cohort
   `"G3YR2"` for generation 3 year 2.  We do not analyze these individuals
   in this analysis.  So we omit them from the output file.

Drop the `"G3YR2"` individuals from GC.
```{r fixup-cohort-subset}
data.primary <- lapply(data.primary, function(x) subset(x, cohort != "G3YR2"))
sapply(data.primary, function(x) unique(sort(x$cohort)))
```

Now convert `"G2YR2"` or `"G2YR3"` to "field".  These labels being
now totally redundant, telling us nothing the year does not also say.
In the following code chunk, `"G2YR[23]"` is a regular expression that
matches either `"G2YR2"` or `"G2YR3"`.
```{r fixup-cohort-labels}
data.primary <- lapply(data.primary, transform, cohort.orig = cohort,
    paternalID.orig = paternalID, maternalID.orig = maternalID) # DEBUG
data.primary <- lapply(data.primary,
    function(x) transform(x, cohort = sub("G2YR[23]", "field", cohort)))
lapply(data.primary, function(x) unique(sort(x$cohort)))
sapply(data.primary, function(x) with(x, is.na(cohort)) |> sum())
```

Now `cohort` is consistent between sites.

## Convert Parental ID Zero to NA

Parental ID Zero indicates "unknown" and hence should be converted
to `NA` to be more R-ish.
```{r zero-to-na}
data.primary <- lapply(data.primary, function(x) transform(x,
    paternalID = ifelse(paternalID == 0, NA_integer_, paternalID),
    maternalID = ifelse(maternalID == 0, NA_integer_, maternalID)))
```

## Remove Individuals with Unknown Parents

For individuals in the `"greenhouse"` cohort, which were pedigreed crosses,
we should have both parents recorded.  Check this.
```{r na-delete-greenhouse}
sapply(data.primary, function(x) with(x, cohort == "greenhouse" &
    (is.na(paternalID) | is.na(maternalID))) |> sum())
sapply(data.primary, function(x) with(x, cohort == "greenhouse" &
    is.na(paternalID)) |> sum())
```
Remove these individuals.
```{r na-delete-greenhouse-doit}
sapply(data.primary, nrow)
data.primary <- lapply(data.primary, function(x) subset(x,
    ! (cohort == "greenhouse" & is.na(paternalID))))
sapply(data.primary, nrow)
```

For individuals in the `"field"` cohort, which were open pollinated, sires
are unknown and this is not a problem but rather by design.  So we
only remove individuals with sire unknown that are not in cohort `"field"`.
We do however need to remove individuals whose mothers are unknown.  Check this.
```{r na-delete-field}
sapply(data.primary, function(x) with(x,
    cohort == "field" & is.na(maternalID)) |> sum())
```

And do the removal.
```{r na-delete-field-doit}
sapply(data.primary, nrow)
data.primary <- lapply(data.primary, function(x) subset(x,
    ! (cohort == "field" & is.na(maternalID))))
sapply(data.primary, nrow)
```

## Final Check for Unknown Parents

```{r check-parents-final}
sapply(data.primary, function(x) with(x, cohort == "greenhouse" &
    (is.na(paternalID) | is.na(maternalID))) |> sum())
sapply(data.primary, function(x) with(x, cohort == "field" &
    is.na(maternalID)) |> sum())
```

## Check for Data Inconsistencies

The aster graph for these data is
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the node labels correspond to variable names in the data frames
and the arrow labels correspond to conditional distributions.  Thus all
of these variables must be nonnegative-integer-valued.
```{r check.integer}
data.primary |> lapply(function(x)
    x[c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")]) |>
    lapply(function(x) sapply(x, function(x) is.integer(x) & all(x >= 0)))
```

Then we must also have
```{r check.constraint}
sapply(data.primary, function(x) with(x, all(Germ <= 1)))
sapply(data.primary, function(x) with(x, all(flw <= Germ)))
sapply(data.primary, function(x)
    with(x, all(total.pods.collected <= total.pods)))
```
So this last check fails.
We will repair in the following section
(Section \@ref(fix-data-inconsistencies)).

In the following block, `(`some logical expression`) <= (`some other logical
expression`)` is an R-ism for the [material implication operator](https://en.wikipedia.org/wiki/Material_conditional), that is, left-hand logical expression
implies right-hand logical expression (if the former is true, then the latter
is true).  This works because the logical expressions are converted
to zero-or-one expressions to be compared with `<=`.  The parentheses are
necessary because of R's operator precedence.
```{r check.constraint-too}
sapply(data.primary, function(x)
    with(x, all((Germ == 0) <= (flw == 0))))
sapply(data.primary, function(x)
    with(x, all((flw == 0) <= (total.pods == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods == 0) <= (total.pods.collected == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods.collected == 0) <= (totalseeds == 0))))
```
So all of these checks pass.

How many individuals have problems?
```{r consistency.check.how.many}
lapply(data.primary, function(x)
    subset(x, total.pods.collected > total.pods)[c("total.pods", "total.pods.collected")])
```

## Fix Data Inconsistencies

So we need to fix up these inconsistencies.
```{r consistency.fixup}
data.primary <- lapply(data.primary, function(x)
    transform(x, total.pods = pmax(total.pods, total.pods.collected)))
```
And recheck.
```{r check.constraint.again}
<<check.constraint>>
<<check.constraint-too>>
```
OK.

# Find Grandfathers

## Introduction

For the `"field"` cohort, we need to find maternal grandfathers (fathers are
unknown).  This is a complicated process, made even more complicated by having
to do this two different ways.

## Method 1 (Only for 2017)

For offspring (`"field"`) planted in 2017, the father is unknown but
the variable `paternalID` stores the maternal grandfather
(rather than the unknown indicator).  This only makes
sense for individuals with `cohort == "field"` of course (for other
individuals paternal ID means paternal ID.
Thus we get grandfathers as follows.
```{r method1}
data.primary <- lapply(data.primary, function(x) transform(x,
    grandpaternalID = ifelse(cohort == "field" & year == 2017,
        paternalID, NA_integer_)))
```

## Method 2 (Only for 2016)

For offspring (`"field"`) planted in 2016, we need a much more complicated
method to find maternal grandfathers.

 * The primary data file says where the individual was planted
   (variables `position` and `row`).

 * The planting data file finds that same individual by those same variables
   (`position` and `row`).

 * The planting data file gives for that individual where its mother was
   planted (variables `maternalposition` and `maternalrow`).

 * If we look up up the mother in the primary data file (by position
   and row), then the `paternalID` for that mother is the required grandfather.

Still using the same data but now we need both primary and secondary data.
```{r method2}
sites <- names(data.primary)
for (site in sites) {
    x <- data.primary[[site]]
    y <- data.planting[[site]]
    key.indiv <- with(x, paste(row, position, sep = ":"))
    key.plant <- with(y, paste(row, position, sep = ":"))
    idx <- match(key.indiv, key.plant)
    # now idx[i] is row index in planting data file of individual
    # having row index i in primary data file
    key.moms <- with(y, paste(maternalrow, maternalposition, sep = ":"))
    idx.moms <- match(key.moms[idx], key.indiv)
    # now idx.moms[i] is row index in primary data file of mother
    # of individual having row index i in primary data file
    data.primary[[site]] <- transform(x, grandpaternalID =
        ifelse(cohort == "field" & year == 2016,
             paternalID[idx.moms], grandpaternalID))
}
```

## Check Grandfathers

```{r grandfather-check}
sapply(data.primary, function(x)
    with(x, sum(cohort == "field" & is.na(grandpaternalID))))
```
Oops!
```{r grandfather-check-too}
sapply(data.primary, function(x)
    with(x, year[cohort == "field" & is.na(grandpaternalID)]))
```
Who are you?
```{r grandfather-check-too-too}
subset(data.primary$GC, cohort == "field" & is.na(grandpaternalID))
```

These individuals are misclassified as to
"cohort".  They are actually generation 3 and should be removed.
This is proved by the planting data file for 2016, which is not
available in this repo.
```{r grandfather-fixup}
data.primary$GC <- subset(data.primary$GC,
    ! (cohort == "field" & is.na(grandpaternalID)))
```

# Make Numerical Variables Categorical

Parental ID variables and `block` are numeric (integer).  But statistically
they are categorical.  So we must make them type `factor` so R will treat
them correctly.
```{r to.factor}
data.primary <- lapply(data.primary, function(x)
    transform(x, maternalID = as.factor(maternalID),
    paternalID = as.factor(paternalID),
    grandpaternalID = as.factor(grandpaternalID),
    block = as.factor(block)))
```

# Tidy Data

One more thing to do.
```{r untidy}
lapply(data.primary, names)
common.names <- lapply(data.primary, names) |> Reduce(intersect, x = _)
common.names
data.primary <- lapply(data.primary, function(x) x[common.names])
```

# Write Out Data

```{r write}
save(data.primary, file = "mf.rda")
```

# References
