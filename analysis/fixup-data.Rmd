---
title: "Preprocessing Data for Estimates of Realized Response to Selection in *Chamaecrista fasciculata* and Decomposition into Environmental and Genetic Parts"
author:
  - "Mason W. Kulbaba^[St. Mary's University, mason.kulbaba@stmu.ca, https://orcid.org/0000-0003-0619-7089]"
  - "Seema N. Sheth^[Department of Plant and Microbial Biology, North Carolina State University, ssheth3@ncsu.edu, https://orcid.org/0000-0001-8284-7608]"
  - "Rachel E. Pain^[Ecology, Evolution and Behavior Graduate Program, University of Minnesota, repain@umn.edu]"
  - "Vincent M. Eckhart^[Department of Biology, Grinnell College, eckhart@grinnell.edu]"
  - "Charles J. Geyer^[School of Statistics, University of Minnesota, geyer@umn.edu, https://orcid.org/0000-0003-1471-1703]"
  - "Ruth G. Shaw^[Department of Ecology, Evolution and Behavior, University of Minnesota, shawx016@umn.edu, https://orcid.org/0000-0001-5980-9291]"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

The git repository for these analyses is
https://github.com/cjgeyer/mf.
This repo is not currently public.

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

 * The version of the `knitr` package used to make this document is
   `r packageVersion("knitr")`.

# Data

## Data Files

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
knitr::opts_chunk$set(error=TRUE)
```

For the analyses here. the data files are
```{r data.files}
files <- list.files(pattern = "*.csv")
files
```
where

 * CS indicates Conard Environmental Research Area (CERA),

 * GC indicates Grey Cloud Dunes Scientific and Natural Area, and

 * KW indicates Kellogg-Weaver Dunes, also called McCarthy Lake,

respectively.  These files include the same data on the same individuals
as in the data files used by @kulbaba-et-al and @zenodo but also include
more individuals, who are offspring of those analyzed before.
For more details, see @kulbaba-et-al
and Section \@ref(rationalize-cohort-labels) below.

As can be seen, we have three kinds of files.

 * Those without `"planting"` in their names are the primary data
   files for the three sites.

 * Those with `"planting_data"` in their names are secondary data files
   used to obtain pedigree information for some analyses.

 * The one with `"planting.data"` in its name is a similar secondary
   data file that we will actually not need to use (but can use for checks).

Distinguish these file types.
```{r distinguish}
files.planting <- grep("planting_data", files, value = TRUE)
files.primary <- grep("planting", files, value = TRUE, invert = TRUE)
files.secondary <- files |> setdiff(files.planting) |> setdiff(files.primary)
files.primary
files.planting
files.secondary
```

Read in some of these files.
```{r read.data}
data.primary <- lapply(files.primary, read.csv)
data.planting <- lapply(files.planting, read.csv)
names(data.primary) <- substr(files.primary, 1, 2) |> toupper()
names(data.primary)
names(data.planting) <- substr(files.planting, 1, 2)
names(data.planting)
```

## NA Cohort Labels

The variable `cohort` in these data frames tells us what generation
the data are.

  * `cohort == "greenhouse"` is the first generation planted.  These
    are pedigreed crosses: both mother and father are known.

  * `cohort %in% c("field", "G2YR2", "G2YR3")` is the second generation
    planted.  These are open pollinated: mother is known, father is unknown.

  * `cohort == "G3YR2"` is the third generation planted.  We do not analyze
    these data in this analysis.

But some individuals are not labeled as to cohort.
```{r show.na.cohort}
sapply(data.primary, function(x) with(x, sum(is.na(cohort))))
```

What do these individuals look like?
```{r show.na.cohort.too}
lapply(data.primary, function(x) subset(x, is.na(cohort)))
```

Delete them.
```{r delete.na.cohort}
data.primary <- lapply(data.primary, function(x) subset(x, ! is.na(cohort)))
```

## Rationalize Cohort Labels

As we said above, these data have a variable `cohort` that is inconsistent
among sites.
```{r show.cohort}
lapply(data.primary, function(x) with(x, split(year, cohort)) |> lapply(unique))
```

 * In site KW, all offspring individuals are labeled as cohort `"field"`.

 * In site CS, offspring in 2016 are labeled as cohort `"field"` and those
   in 2017 are labeled as cohort `"G2YR3"` for generation 2 year 3
   apparently because 2017 is the third year of the whole experiment.

 * In site GC, offspring in 2016 are labeled as cohort `"field"` and those
   in 2017 are labeled as cohort `"G2YR2"` for generation 2 year 2
   apparently because 2017 is the second year of the experiment *in which
   offspring were planted*.

 * In site GC, there are also offspring of offspring labeled as cohort
   `"G3YR2"` for generation 3 year 2.  We do not analyze these individuals
   in this analysis.  So we omit them from the output file.

Drop the `"G3YR2"` individuals from GC.
```{r fixup-cohort-subset}
data.primary <- lapply(data.primary, function(x) subset(x, cohort != "G3YR2"))
sapply(data.primary, function(x) unique(sort(x$cohort)))
```

Now convert `"G2YR2"` or `"G2YR3"` to "field".  These labels being
now totally redundant, telling us nothing the year does not also say.
In the following code chunk, `"G2YR[23]"` is a regular expression that
matches either `"G2YR2"` or `"G2YR3"`.
```{r fixup-cohort-labels}
data.primary <- lapply(data.primary,                # DEBUG
    function(x) transform(x, cohort.orig = cohort)) # DEBUG
data.primary <- lapply(data.primary,
    function(x) transform(x, cohort = sub("G2YR[23]", "field", cohort)))
lapply(data.primary, function(x) unique(sort(x$cohort)))
sapply(data.primary, function(x) with(x, is.na(cohort)) |> sum())
```

Now `cohort` is consistent between sites.

## Remove Parental ID Zero

Parental ID Zero indicates "unknown" and hence should be removed from
these analyses.   We have to do this carefully because
for individuals in the `"field"` cohort, which were open pollinated, sires
are unknown and this is not a problem but rather by design.  So we
only remove individuals with sire unknown that are not in cohort `"field"`.

Check how many we are going to remove.  Since operator precedence in R
is from highest to lowest `==` and `!=` (same level) then `&` and then `|`,
the following does do what is wanted.
```{r check.parental.zero}
sapply(data.primary, function(x)
    sum(with(x, maternalID == 0 | cohort != "field" & paternalID == 0)))
```
And do the removal.
```{r remove.parental.zero}
data.primary <- lapply(data.primary, function(x)
    subset(x, ! (maternalID == 0 | cohort != "field" & paternalID == 0)))
```

## Make Numerical Variables Categorical

Parental ID variables and `block` are numeric (integer).  But statistically
they are categorical.  So we must make them type `factor` so R will treat
them correctly.
```{r to.factor}
data.primary <- lapply(data.primary, function(x)
    transform(x, maternalID = as.factor(maternalID),
    paternalID = as.factor(paternalID), block = as.factor(block)))
```

## Check for Data Inconsistencies

The aster graph for these data is
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the node labels correspond to variable names in the data frames
and the arrow labels correspond to conditional distributions.  Thus all
of these variables must be nonnegative-integer-valued.
```{r check.integer}
data.primary |> lapply(function(x)
    x[c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")]) |>
    lapply(function(x) sapply(x, function(x) is.integer(x) & all(x >= 0)))
```

Then we must also have
```{r check.constraint}
sapply(data.primary, function(x) with(x, all(Germ <= 1)))
sapply(data.primary, function(x) with(x, all(flw <= Germ)))
sapply(data.primary, function(x)
    with(x, all(total.pods.collected <= total.pods)))
```
So this last check fails.
We will repair in the following section
(Section \@ref(fix-data-inconsistencies)).

In the following block, `(`some logical expression`) <= (`some other logical
expression`)` is an R-ism for the [material implication operator](https://en.wikipedia.org/wiki/Material_conditional), that is, left-hand logical expression
implies right-hand logical expression (if the former is true, then the latter
is true).  This works because the logical expressions are converted
to zero-or-one expressions to be compared with `<=`.  The parentheses are
necessary because of R's operator precedence.
```{r check.constraint-too}
sapply(data.primary, function(x)
    with(x, all((Germ == 0) <= (flw == 0))))
sapply(data.primary, function(x)
    with(x, all((flw == 0) <= (total.pods == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods == 0) <= (total.pods.collected == 0))))
sapply(data.primary, function(x)
    with(x, all((total.pods.collected == 0) <= (totalseeds == 0))))
```
So all of these checks pass.

How many individuals have problems?
```{r consistency.check.how.many}
lapply(data.primary, function(x)
    subset(x, total.pods.collected > total.pods)[c("total.pods", "total.pods.collected")])
```

## Fix Data Inconsistencies

So we need to fix up these inconsistencies.
```{r consistency.fixup}
data.primary <- lapply(data.primary, function(x)
    transform(x, total.pods.collected = pmin(total.pods, total.pods.collected)))
```
And recheck.
```{r check.constraint.again}
<<check.constraint>>
<<check.constraint-too>>
```
OK.

# Find Grandfathers

## Introduction

For the `"field"` cohort, we need to find maternal grandfathers (fathers are
unknown).  This is a complicated process, made even more complicated by having
to do this three different ways.

### Method 1 (Only for GC Data)

If the dataset has a `positionID` variable, then this identifies
individuals in the same way that `paternalID` and `maternalID` do,
that is, if `x` is the data frame
```{r method1-data}
site <- "GC"
x <- data.primary[[site]]
```
then
```{r method1-idx}
idx <- with(x, match(maternalID, positionID))
```
finds the row indices of mothers of individuals, hence
```{r method1-gramps}
gramps <- with(x, paternalID[idx])
```
finds grandfathers.  Check that this worked
```{r method1-check}
with(x, (cohort == "field") <= (! is.na(gramps))) |> all()
```

### Method 2 (Only for CS and KW Data)

```{r method2-data}
site <- "CS"
x <- data.primary[[site]]
```
For some individuals `paternalID` (which should be 0 for unknown) the
grandpaternal ID is actually stored in `paternalID`.  This only makes
sense for individuals with `cohort == "field"` of course (for other
individuals paternal ID means paternal ID.

```{r method2-gramps}
gramps <- with(x, paternalID)
gramps[x$cohort != "field"] <- NA
gramps[gramps == 0] <- NA
```

We do not expect this to work (have to apply method 3 too).
```{r method2-check}
with(x, mean(is.na(gramps[cohort == "field"])))
```
Above should be zero but isn't.

### Method 3 (Only for CS and KW Data)

Still using the same data but now we need both primary and secondary data.
```{r method3-data}
site
x <- data.primary[[site]]
y <- data.planting[[site]]
```
Now individuals are found by `row` and `position` in both data sets.  So
```{r method3-planting}
key.indiv <- with(x, paste(row, position, sep = ":"))
key.plant <- with(y, paste(row, position, sep = ":"))
idx <- match(key.indiv, key.plant)
```
Now `idx[i]` is the row index in the planting data file of the individual
that has row index `i` in the primary data file. And
```{r method3-mothers}
key.moms <- with(y, paste(maternalrow, maternalposition, sep = ":"))
idx.moms <- match(key.moms[idx], key.indiv)
```
Now `idx.moms[i]` is the row index in the primary data file of the
the mother of the individual
that has row index `i` in the primary data file. And
```{r method3-gramps}
gramps.too <- with(x, paternalID[idx.moms])
gramps.too[x$cohort != "field"] <- NA
gramps.too[gramps.too == 0] <- NA
```
looks up the fathers of those mothers.

We do not expect this to work either (have to combine with results of method 2).
```{r method3-check}
with(x, mean(is.na(gramps.too[cohort == "field"])))
```
Above should be zero but isn't.

### Checking Consistency and Exhaustiveness of Methods 2 and 3

Check that `gramps` and `gramps.too` say the same thing when not `NA`.
```{r method.2.3.consist}
all(gramps == gramps.too, na.rm = TRUE)
data.frame(method2 = gramps, method3 = gramps.too, cohort = x$cohort.orig,
    year = x$year) |> subset(gramps != gramps.too)
```

Check that one or the other of `gramps` and `gramps.too` is not `NA`.
```{r method.2.3.exhaust}
with(x, (cohort == "field") <= (! is.na(gramps) | (! is.na(gramps.too)))) |> all()
```

## The GC Data (REVISED DOWN TO HERE)

```{r particular.gc}
foo <- data.primary[[site]]
names(foo)
```
For these data, `positionID` is the ID of the individual
(row of the data frame), and `maternalID` is the ID of the maternal plant.
So the grandfather is the `paternalID` of this maternal plant.
```{r keys-gc}
foobar <- with(foo, match(maternalID, positionID))
```
R object `foobar` is now the index (row number) of the mother of the
corresponding individual, that is, the individual in row `i` has their
mother in row `foobar[i]`.  Hence the father of that mother has ID
`foo$paternalID[foobar]`.
```{r grandsires}
data.primary[[site]] <- transform(data.primary[[site]],
    grandpaternalID = paternalID[foobar])
```

Check that we have grandfathers for all `"field"` individuals
```{r check-grandsires}
with(data.primary[[site]],
     all((cohort == "field") <= (! is.na(grandpaternalID))))
```

## The CS Data

For the other two data sets we do something completely different
(and, partially, different from each other).
Reset the DRY/SPOT variable
```{r dry.spot-too}
site <- "CS"
```
And the data frames (both of them) are
```{r particular}
foo <- data.primary[[site]]
bar <- data.planting[[site]]
```
```{r particular-too}
names(foo)
names(bar)
```
Variables `"row"` and `"position"` tell where an individual is
(in both data frames).
Variables `"maternalrow"` and `"maternalposition"` tell where the mother
of the corresponding individual is.
R function `match` allows us to match
these up, but needs single things to match.  So we paste row and position
together to make one "key".
In the check, `<=` is again the [material implication
operator](https://en.wikipedia.org/wiki/Material_conditional).
```{r keys}
foo.key <- with(foo, paste(row, position, sep = ":"))
bar.key <- with(bar, paste(row, position, sep = ":"))
baz.key <- with(bar, paste(maternalrow, maternalposition, sep = ":"))
sort(foo.key) |> head()
sort(bar.key) |> head()
foobar <- match(foo.key, bar.key)
all((foo$cohort == "field") <= (! is.na(foobar)))
sum(foo$cohort == "field")
sum(foo$cohort == "field" & is.na(foobar))
with(foo, unique(year[cohort == "field" & is.na(foobar)]))
with(foo, unique(year[cohort == "field" & (! is.na(foobar))]))
with(foo, unique(cohort.orig[cohort == "field" & is.na(foobar)]))
with(foo, unique(cohort.orig[cohort == "field" & (! is.na(foobar))]))
```
R object `foobar` is now a vector whose length is the row dimension
of data frame `foo` (which is `data.primary[[site]]`) and whose
values (if not `NA`)
give the row index of the corresponding individual in data frame `bar`
(which is `data.planting[[site]]`).

So far, so good.  Now we look up the maternal position.
```{r keys-too}
qux.key <- baz.key[foobar]
all((foo$cohort == "field") <= (! is.na(qux.key)))
```

Then we find those mothers.
```{r keys-too-too}
fooqux <- match(qux.key, foo.key)
```

And finally, we find the fathers of those mothers.
```{r keys-too-too-too}
data.primary[[site]] <- transform(data.primary[[site]],
    grandpaternalID = paternalID[fooqux])
with(data.primary[[site]],
    all((cohort == "field") <= (! is.na(grandpaternalID))))
```

We check that we indeed did what we intended to do.  Find a random
`"field"` individual.
```{r random.field}
i <- sample(which(with(foo, cohort == "field")), 1)
foo[i, ]
bar[foobar[i], ]
foo[fooqux[i], ]
data.primary[[site]]$grandpaternalID[i]
stopifnot(foo[i, "row"] == bar[foobar[i], "row.1"])
stopifnot(foo[i, "position"] == bar[foobar[i], "position.1"])
stopifnot(bar[foobar[i], "maternalrow"] == foo[fooqux[i], "row"])
stopifnot(bar[foobar[i], "maternalposition"] == foo[fooqux[i], "position"])
stopifnot(foo[fooqux[i], "paternalID"] ==
    data.primary[[site]]$grandpaternalID[i])
```
Everything checks (note that because we did not set a random seed, this
checks for a different random individual every time the file is processed).

## The KW Data

Now we do exactly the same thing for
```{r dry.spot-too-too}
site <- "KW"
```
Do it.
```{r redo}
<<particular>>
<<keys>>
<<keys-too>>
<<keys-too-too>>
gramps <- with(data.primary[[site]], paternalID[fooqux])
all((foo$cohort == "field") <= (! is.na(gramps)))
```

This does not work.  Site KW is not like site CS.
Find out where the problems are.
```{r find.out}
with(foo, year[foo$cohort == "field" & is.na(gramps)]) |> unique()
with(foo, year[foo$cohort == "field" & (! is.na(gramps))]) |> unique()
```

It turns out that the grandfathers we have failed to find with the code
above, are actually in the `paternalID` field for these individuals, that is,
"paternal" here means maternal grandfathers (which are known) rather than
fathers (which are unknown).
```{r find.out.too}
all(with(foo, paternalID[cohort == "field" & is.na(gramps)]) != 0)
gramps[foo$cohort == "field" & foo$year == 2017] <-
    foo$paternalID[foo$cohort == "field" & foo$year == 2017]
all((foo$cohort == "field") <= (! is.na(gramps)))
```
Looks OK.
```{r kw.gramps}
data.primary[[site]]$grandpaternalID <- gramps
```

# Check Agreement with Old Analyses

Check that these agree with old analyses.
```{r check.with.old}
load("KW_subdatfield.rda")
old <- with(subdatfield, grandfather)
new <- with(data.primary$KW, grandpaternalID[cohort == "field" & year == 2016])
identical(as.character(old), as.character(new))
load("GC_subdatfield.rda")
old <- with(subdatfield, grandfather)
new <- with(data.primary$GC, grandpaternalID[cohort == "field" & year == 2016])
identical(as.character(old), as.character(new))
```

# Check Agreement with Secondary Data File

```{r secondary.names}
site
foo <- data.primary[[site]]
bar <- read.csv(files.secondary)
names(bar)
<<keys>>
all((foo$cohort == "field" & foo$year == 2017) <= (! is.na(foobar)))
<<keys-too>>
<<keys-too-too>>
all((foo$cohort == "field" & foo$year == 2017) <= (! is.na(qux.key)))
```
Now we repeat the checks we did above for the CS data.
Except now for a 2017 individual
```{r random.field.too}
i <- sample(which(with(foo, cohort == "field" & year == 2017)), 1)
foo[i, ]
bar[foobar[i], ]
foo[fooqux[i], ]
data.primary[[site]]$grandpaternalID[i]
stopifnot(foo[i, "row"] == bar[foobar[i], "row.1"])
stopifnot(foo[i, "position"] == bar[foobar[i], "position.1"])
stopifnot(bar[foobar[i], "maternalrow"] == foo[fooqux[i], "row"])
stopifnot(bar[foobar[i], "maternalposition"] == foo[fooqux[i], "position"])
stopifnot(foo[fooqux[i], "paternalID"] ==
    data.primary[[site]]$grandpaternalID[i])
```
So all of that checks too.

# Tidy Data

One more thing to do.
```{r untidy}
lapply(data.primary, names)
common.names <- lapply(data.primary, names) |> Reduce(intersect, x = _)
common.names
data.primary <- lapply(data.primary, function(x) x[common.names])
```

# Write Out Data

```{r write}
save(data.primary, file = "mf.rda")
```

# References
