---
title: "Estimates of Realized Response to Selection in *Chamaecrista fasciculata* and Decomposition into Environmental and Genetic Parts"
author:
  - "Mason W. Kulbaba^[St. Mary's University, mason.kulbaba@stmu.ca, https://orcid.org/0000-0003-0619-7089]"
  - "Seema N. Sheth^[Department of Plant and Microbial Biology, North Carolina State University, ssheth3@ncsu.edu, https://orcid.org/0000-0001-8284-7608]"
  - "Rachel E. Pain^[Ecology, Evolution and Behavior Graduate Program, University of Minnesota, repain@umn.edu]"
  - "Vincent M. Eckhart^[Department of Biology, Grinnell College, eckhart@grinnell.edu]"
  - "Charles J. Geyer^[School of Statistics, University of Minnesota, geyer@umn.edu, https://orcid.org/0000-0003-1471-1703]"
  - "Ruth G. Shaw^[Department of Ecology, Evolution and Behavior, University of Minnesota, shawx016@umn.edu, https://orcid.org/0000-0001-5980-9291]"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
    number_sections: true
    toc: true
    toc_depth: 3
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# Abstract {-}

This work builds on @kulbaba-et-al and the correction to it [@zenodo]
to obtain estimates of the realized response to natural selection.
Those articles
presented estimates of mean fitness and additive genetic variance for fitness
for three populations of *Chamaecrista fasciculata*,
each grown in its home location in three years via aster analyses
of records of components of fitness for a pedigreed set of individuals.
Here, we consider the realized change in mean fitness from one generation
to the next, for comparison with the prediction from Fisher's
Fundamental Theorem of Natural Selection (FFTNS).
We divide change in mean fitness in one generation
into three parts:
that due to change in genetic composition described by FFTNS,
that due to change in genetic composition not described by FFTNS, and
that due to change in environment.
Here, we obtain estimates of a) mean fitness of the pedigreed parental
populations before selection (previously presented in @kulbaba-et-al and its
correction); b) mean fitness of the pedigreed parental population after
selection (i.e. accounting for the change in representation of the families
reflected in differential seed production); and mean fitness of the offspring
of the pedigreed sets
(i. e., the outcome of natural selection on the parental
generation when grown in the same sites in the following year).

We also obtain standard errors of our estimates.
In this we use a new scheme that treats random effects as parameters
to estimate because we do use estimates of random effects in our estimates
of mean fitness.

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

The R markdown source for this document is the file `realized.Rmd`
in the GitHub private repository https://github.com/cjgeyer/mf
which will be made public whenever a paper based on it is submitted.

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

 * The version of the `aster` package used to make this document is
   `r packageVersion("aster")`.

 * The version of the `numDeriv` package used to make this document is
   `r packageVersion("numDeriv")`.

 * The version of the `Matrix` package used to make this document is
   `r packageVersion("Matrix")`.

 * The version of the `parallel` package used to make this document is
   `r packageVersion("parallel")`.

 * The version of the `alabama` package used to make this document is
   `r packageVersion("alabama")`.

Attach packages.
```{r package}
library("aster")
library("numDeriv")
library("Matrix")
library("parallel")
options("mc.cores" = detectCores())
library("alabama")
```

Need at least version 1.3-4 of R package `aster` for R generic function `vcov`
to work on results of calls to R functions `aster` and `reaster`.
```{r aster-version}
stopifnot(compareVersion(as.character(packageVersion("aster")), "1.3-4") >= 0)
```

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
# knitr::opts_chunk$set(error=TRUE)
```

# Data

## Files

```{r key.gc, echo=FALSE}
key.data <- tools::md5sum("mf.rda")
```

For the analyses here. the data files are
```{r data.input}
load("mf.rda")
ls()
sapply(data.primary, class)
```
for 

 * Conard Environmental Research Area (CERA),

 * Grey Cloud Dunes Scientific and Natural Area, and

 * Kellogg-Weaver Dunes, also called McCarthy Lake,

respectively.  These files include the same data on the same individuals
as in the data files used by @kulbaba-et-al and @zenodo but also include
more individuals, who are offspring of those analyzed before.
For more details, see @kulbaba-et-al.

Much preprocessing of these data has already been done.  See
the file `fixup-data.pdf` in this repository.

## Structure

We do aster analyses with random effects (@aster2, @reaster) for
an aster model with graph
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the variables are

 * `Germ` is germination indicator (0 = no, 1 = yes), conditionally Bernoulli.

 * `flw` is survival to flowering (0 = no, 1 = yes),
    conditionally Bernoulli.

 * `total.pods` is total number of pods produced,
   conditionally Poisson.

 * `total.pods.collected` is number of pods collected,
   conditionally Bernoulli (i.e. each pod may be collected or not).
   The arrow leading to this node
   is a subsampling arrow.  The number of pods collected is
   a random sample of the pods produced.

 * `totalseeds` is total number of seeds counted from collected pods,
   conditionally Poisson.

As always with aster models, the name of the distribution for an arrow
is the name of the conditional distribution of the successor variable
given the predecessor variable.
The arrow labeled `samp` is a subsampling arrow.  It is a Bernoulli
arrow but the sampling is experimental rather than biological.
This arrow may be [missing in some analyses](#alternative-structure).

Set graphical model description in R.
```{r graph}
vars <- c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")
pred <- c(0, 1, 2, 3, 4)
fam <- c(1, 1, 2, 1, 2)
```

## Alternative Structure

Get years.
```{r years}
years <- sort(unique(data.primary[[1]]$year))
names(years) <- years
years

years.offspring <- with(data.primary[[1]], year[cohort == "field"]) |>
    sort() |> unique()
names(years.offspring) <- years.offspring
years.offspring
```

And for each site-year combination, subset data for parents
(`cohort == "greenhouse"`) and check for presence of subsampling.
```{r check.subsampling.parents}
samp.parents <- lapply(data.primary, function(x) lapply(years, function(y) {
    subdat <- subset(x, year == y & cohort == "greenhouse")
    subdat <- droplevels(subdat)
    with(subdat, any(total.pods > total.pods.collected))
    }))
samp.parents
```
We see that we have two parental generation analyses (out of nine) in which
there is no subsampling.  For these we have to change the aster graph for
individuals to omit the subsampling arrow.
```{r graph.no.subsamp}
vars.no.samp <- c("Germ", "flw", "total.pods", "totalseeds")
pred.no.samp <- c(0, 1, 2, 3)
fam.no.samp <- c(1, 1, 2, 2)
```

Now do the same check for offspring
(`cohort == "field"`).
```{r check.subsampling.offspring}
samp.offspring <- lapply(data.primary, function(x)
    lapply(years.offspring, function(y) {
    subdat <- subset(x, year == y & cohort == "field")
    subdat <- droplevels(subdat)
    with(subdat, any(total.pods > total.pods.collected))
    }))
samp.offspring
```
So no issues with this for offspring: all offspring generation analyses
have subsampling.

# Analyses with R Function Reaster

## Parents

We have nine analyses to do here, one for each site-year combination.

We have three covariates: sire, dam, and block, which we make random effects.
We `cbind` the model matrices for sire and dam, so they share a variance
component.
```{r reaster.parents, cache=TRUE, cache.extra=key.data}
rout.parents <- mclapply(data.primary, function(x) mclapply(years, function(y) {
    subdat <- subset(x, year == y & cohort == "greenhouse")
    subdat <- droplevels(subdat)
    has.subsamp <- with(subdat, any(total.pods > total.pods.collected))
    if (has.subsamp) {
        redata <- reshape(subdat, varying = list(vars), direction = "long",
            timevar = "varb", times = as.factor(vars), v.names = "resp")
    } else {
        redata <- reshape(subdat, varying = list(vars.no.samp),
            direction = "long", timevar = "varb",
            times = as.factor(vars.no.samp), v.names = "resp")
    }
    redata <- transform(redata,
        fit = as.numeric(grepl("totalseeds", as.character(varb))),
        root = 1)
    modmat.sire <- model.matrix(~ 0 + fit:paternalID, redata)
    modmat.dam <- model.matrix(~ 0 + fit:maternalID, redata)
    modmat.siredam <- cbind(modmat.sire, modmat.dam)
    if (has.subsamp) {
        reaster(resp ~ fit + varb,
            list(parental = ~ 0 + modmat.siredam, block = ~ 0 + fit:block),
            pred, fam, varb, id, root, data = redata)
    } else {
        reaster(resp ~ fit + varb,
            list(parental = ~ 0 + modmat.siredam, block = ~ 0 + fit:block),
            pred.no.samp, fam.no.samp, varb, id, root, data = redata)
    }
    }, mc.preschedule = FALSE), mc.preschedule = FALSE)
```

Let's see what we got.
Check what we got.
```{r quid.est.happening}
lapply(rout.parents, function(x) sapply(x, function(x) inherits(x, "reaster")))
```

Any variance components estimated to be zero?
```{r quid.est.happening.too}
lapply(rout.parents, function(x) sapply(x, function(x) x$nu))
```
One case where block effects are estimated to be zero,
but all cases have parental effects estimated to be nonzero,
which is what we want.

## Offspring

We have six analyses to do here, one for each site-year combination
(in which there are offspring).
```{r reaster.offspring, cache=TRUE, cache.extra=key.data}
rout.offspring <- mclapply(data.primary,
    function(x) mclapply(years.offspring, function(y) {
    subdat <- subset(x, year == y & cohort == "field")
    subdat <- droplevels(subdat)
    redata <- reshape(subdat, varying = list(vars), direction = "long",
        timevar = "varb", times = as.factor(vars), v.names = "resp")
    redata <- transform(redata,
        fit = as.numeric(grepl("totalseeds", as.character(varb))),
        root = 1)
    reaster(resp ~ fit + varb,
        list(parental = ~ 0 + fit:grandpaternalID, block = ~ 0 + fit:block),
        pred, fam, varb, id, root, data = redata)
    }))
```

Let's see what we got.
Check what we got.
```{r quid.est.happening.offspring}
lapply(rout.offspring, function(x)
    sapply(x, function(x) inherits(x, "reaster")))
```

Any variance components estimated to be zero?
```{r quid.est.happening.too.offspring}
lapply(rout.offspring, function(x) sapply(x, function(x) x$nu))
```
No case where any variance components are estimated to be zero.

# Asymptotic Variance-Covariance Matrices of Estimates

## Parents

```{r vcov.parents, cache=TRUE, dependson="reaster.parents"}
vcov.parents <- mclapply(rout.parents, function(x)
    mclapply(x, vcov, complete = TRUE, re.too = TRUE,
    standard.deviation = FALSE))
```

## Offspring

```{r vcov.offspring, cache=TRUE, dependson="reaster.offspring"}
vcov.offspring <- mclapply(rout.offspring, function(x)
    mclapply(x, vcov, complete = TRUE, re.too = TRUE,
    standard.deviation = FALSE))
```

# Mapping Sire and Grandsire Effects to Mean Values

We follow Section 9 of @zenodo *mutatis mutandis*.  The main changes are
here we will have a vectorizing function that simultaneously does
mean fitness values for a specified set of individuals.
```{r map}
map.factory <- function(rout) {
    stopifnot(inherits(rout, "reaster"))
    aout <- rout$obj
    stopifnot(inherits(aout, "aster"))
    nnode <- ncol(aout$x)
    nind <- nrow(aout$x)
    fixed <- rout$fixed
    random <- rout$random
    if (nnode == 4) {
        is.subsamp <- rep(FALSE, 4)
    } else if (nnode == 5) {
        is.subsamp <- c(FALSE, FALSE, FALSE, TRUE, FALSE)
    } else stop("can only deal with graphs for individuals with 4 or 5 nodes",
        "\nand graph is linear, and subsampling arrow is 4th of 5")
    # fake object of class aster
    randlab <- unlist(lapply(rout$random, colnames))
    include.random <- grepl("paternalID", randlab, fixed = TRUE)
    fake.out <- aout
    fake.beta <- with(rout, c(alpha, b[include.random]))
    modmat.random <- Reduce(cbind, random)
    stopifnot(ncol(modmat.random) == length(rout$b))
    modmat.random <- modmat.random[ , include.random, drop = FALSE] 
    fake.modmat <- cbind(fixed, modmat.random)
    # now have to deal with objects of class aster (as opposed to reaster)
    # thinking model matrices are three-way arrays.
    stopifnot(prod(dim(aout$modmat)[1:2]) == nrow(fake.modmat))
    fake.modmat <- array(as.vector(fake.modmat),
        dim = c(dim(aout$modmat)[1:2], ncol(fake.modmat)))
    fake.out$modmat <- fake.modmat
    nparm <- length(rout$alpha) + length(rout$b) + length(rout$nu)
    is.alpha <- 1:nparm %in% seq_along(rout$alpha)
    is.bee <- 1:nparm %in% (length(rout$alpha) + seq_along(rout$b))
    is.nu <- (! (is.alpha | is.bee))
    # figure out individuals from each family
    m <- rout$random$parental
    dads <- grep("paternal", colnames(m))
    # get family, that is, paternalID or grandpaternalID as the case may be
    fams <- colnames(m)[dads] |> sub("^.*ID", "", x = _)
    # drop maternal effects columns (if any)
    m.dads <- m[ , dads, drop = FALSE]
    # make into 3-dimensional array, like obj$modmat
    m.dads <- array(m.dads, c(nind, nnode, ncol(m.dads)))
    # only keep fitness node
    # only works for linear graph
    m.dads <- m.dads[ , nnode, ]
    # redefine dads as families of individuals
    stopifnot(as.vector(m.dads) %in% c(0, 1))
    stopifnot(rowSums(m.dads) == 1)
    # tricky, only works because each row of m.dads
    # is indicator vector of family,
    # so we are multiplying family number by zero or one
    dads <- drop(m.dads %*% as.integer(fams))
    # find one individual in each family
    sudads <- sort(unique(dads))
    which.ind <- match(sudads, dads)
    function(alphabeenu) {
        stopifnot(is.numeric(alphabeenu))
        stopifnot(is.finite(alphabeenu))
        stopifnot(length(alphabeenu == nparm))
        alpha <- alphabeenu[is.alpha]
        bee <- alphabeenu[is.bee]
        nu <- alphabeenu[is.sigma]
        fake.beta <- c(alpha, bee[include.random])
        fake.out$coefficients <- fake.beta
        pout <- predict(fake.out, model.type = "conditional",
            is.always.parameter = TRUE)
        xi <- matrix(pout, ncol = nnode)
        xi <- xi[ , ! is.subsamp, drop = FALSE]
        mu <- apply(xi, 1, prod)
        mu <- mu[which.ind]
        names(mu) <- paste0("PID", formatC(sudads, format="d", width=3, flag="0"))
        return(mu)
    }
}
```

R function `map.factory` has one argument, an object of class `reaster`
produced by a call to R function `reaster` and produces a function with
one argument, which is a vector $\theta = (\alpha, c, \sigma)$ that contains
the variables (fixed effects, standardized random effects, and standard
deviation components), and that produced function returns
mean fitness estimates for one individual from each "family" (sire for
parental fits, grandsire for offspring fits).
That is, it is a function whose value is another function.

**Warning:** This function only works for linear aster graphs for "individuals"
(in scare quotes) having four or five arrows and the only subsampling is the
fourth of five.

Try it out.
```{r fitness-try-out}
rout <- rout.parents[[1]][[1]]
inherits(rout, "reaster")
names(rout)
map <- map.factory(rout)
theta <- with(rout, c(alpha, c, sigma))
map(theta)
```

## Change in Mean Fitness Due to Selection

These are the primary estimates of interest.  We can compute many functions
of them that are of biological interest.  First, for the parental fits, we
compute the change in mean fitness in one generation "due to selection before
reproduction", that is, population mean fitness minus the same weighted by
relative fitness.

### One Analysis

As always, we try one example, and then automate.
```{r try-one-mf}
site <- "CS"
year <- "2015"
rout <- rout.parents[[site]][[year]]
objfun <- with(rout, objfun.factory(fixed, random, response,
    obj$pred, obj$fam, as.vector(obj$root), zwz = zwz,
    standard.deviation = TRUE, deriv = 1))
theta.hat <- with(rout, c(alpha, c, sigma))
map <- map.factory(rout)
parfun <- function(theta) {
    foo <- map(theta)
    bar <- foo / sum(foo)
    baz <- bar - 1 / length(bar)
    sum(baz * foo)
}
```

Here `parfun` is the function we want to maximize or minimize over the
likelihood-based confidence region, just as for the single parameter above.
```{r try-one-mf-ci, error=TRUE}
lmin <- objfun(theta.hat)$value |> print()
hoo <- function(theta) crit - 2 * (objfun(theta)$value - lmin)
joo <- function(theta) rbind(- 2 * objfun(theta)$gradient)
aout <- auglag(theta.hat, fn = parfun, hin = hoo, hin.jac = joo,
    control.outer = list(trace = FALSE))
aout$convergence == 0
lower <- aout$value |> print()
```

# References

