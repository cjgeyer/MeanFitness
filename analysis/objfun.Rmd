---
title: "New Objective Function for Reaster Problem"
author: "Charles J. Geyer"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
    number_sections: true
    toc: true
    toc_depth: 3
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

The R markdown source for this document is the file `realized.Rmd`
in the GitHub private repository https://github.com/cjgeyer/mf
which will be made public whenever a paper based on it is submitted.

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

 * The version of the `aster` package used to make this document is
   `r packageVersion("aster")`.

 * The version of the `numDeriv` package used to make this document is
   `r packageVersion("numDeriv")`.

 * The version of the `Matrix` package used to make this document is
   `r packageVersion("Matrix")`.

Attach packages.
```{r package}
library("aster")
library("numDeriv")
library("Matrix")
```

Need at least version 1.3.0 of R package `aster` for
R function `objfun.factory` that makes objective function for aster models
with random effects (Laplace approximation to actual log likelihood)
equation (7) of @reaster except that R function `objfun.factory` no longer
uses the ``second approximation'' that treats $\widehat{W}$ in that equation
as a constant matrix.  Hence we should rewrite it as
\begin{equation}
\begin{equation} \label{eq:pee}
\begin{split}
   p(\alpha, b, \nu)
   & =
   - l(a + M \alpha + Z b)
   + \tfrac{1}{2} b^T D^{-1} b
   \\
   & \quad
   + \tfrac{1}{2} \log
   \det\bigl[ Z^T W(a + M \alpha + Z b) Z D + I \bigr]
\end{split}
\end{equation}

```{r aster-version}
stopifnot(compareVersion(as.character(packageVersion("aster")), "1.3") >= 0)
```

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
# knitr::opts_chunk$set(error=TRUE)
```

# Data

For the analyses here. the data files are
```{r data.input}
load("mf.rda")
ls()
sapply(data.primary, class)
```
for 

 * Conard Environmental Research Area (CERA),

 * Grey Cloud Dunes Scientific and Natural Area, and

 * Kellogg-Weaver Dunes, also called McCarthy Lake,

respectively.  These files include the same data on the same individuals
as in the data files used by @kulbaba-et-al and @zenodo but also include
more individuals, who are offspring of those analyzed before.
For more details, see @kulbaba-et-al.

Much preprocessing of these data has already been done.  See
the file `fixup-data.pdf` in this repository.

# Introduction

We do aster (@aster2, @reaster) analyses for an aster model with graph
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the variables are

 * `Germ` is germination indicator (0 = no, 1 = yes), conditionally Bernoulli.

 * `flw` is survival to flowering (0 = no, 1 = yes),
    conditionally Bernoulli.

 * `total.pods` is total number of pods produced,
   conditionally Poisson.

 * `total.pods.collected` is number of pods collected,
   conditionally Bernoulli (i.e. each pod may be collected or not).
   The arrow leading to this node
   is a subsampling arrow.  The number of pods collected is
   a random sample of the pods produced.

 * `totalseeds` is total number of seeds counted from collected pods,
   conditionally Poisson.

As always with aster models, the name of the distribution for an arrow
is the name of the conditional distribution of the successor variable
given the predecessor variable.
The arrow labeled `samp` is a subsampling arrow.  It is a Bernoulli
arrow but the sampling is experimental rather than biological.

Set graphical model description in R.
```{r graph}
vars <- c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")
pred <- c(0, 1, 2, 3, 4)
fam <- c(1, 1, 2, 1, 2)
```

```{r key.gc, echo=FALSE}
key.data <- tools::md5sum("mf.rda")
```

# Analyses with R Function Reaster

## Parents

We have nine analyses to do here, one for each site-year combination.
```{r reaster.parents, cache=TRUE, cache.extra=key.data}
years <- sort(unique(data.primary[[1]]$year))
names(years) <- years
years
rout.parents <- lapply(data.primary, function(x) lapply(years, function(y) {
    subdat <- subset(x, year == y & cohort == "greenhouse")
    subdat <- droplevels(subdat)
    redata <- reshape(subdat, varying = list(vars), direction = "long",
        timevar = "varb", times = as.factor(vars), v.names = "resp")
    redata <- transform(redata,
        fit = as.numeric(grepl("totalseeds", as.character(varb))),
        root = 1)
    modmat.sire <- model.matrix(~ 0 + fit:paternalID, redata)
    modmat.dam <- model.matrix(~ 0 + fit:maternalID, redata)
    modmat.siredam <- cbind(modmat.sire, modmat.dam)
    reaster(resp ~ fit + varb,
        list(parental=~0 + modmat.siredam, block = ~ 0 + fit:block),
        pred, fam, varb, id, root, data = redata)
    }))
```

Check what we got.
```{r quid.est.happening}
sapply(rout.parents, class)
lapply(rout.parents, names)
lapply(rout.parents, function(x) sapply(x, function(x) inherits(x, "reaster")))
```

Summaries.
```{r summary.reaster.parents, cache=TRUE, depends="reaster.parents"}
sout.parents <- lapply(rout.parents, function(x) lapply(x, summary))
```
```{r quid.est.happening.too}
lapply(sout.parents, function(x)
    sapply(x, function(x) inherits(x, "summary.reaster")))
lapply(sout.parents, function(x) lapply(x, function(x) x$nu[ , "Estimate"]))
```

Check that variance-covariance calculation also works.
```{r vcov.reaster.parents, cache=TRUE, depends="reaster.parents"}
vout.parents <- lapply(rout.parents, function(x)
    lapply(x, function(x) try(vcov(x, standard.deviation = FALSE,
        re.too = TRUE, complete = TRUE), silent = TRUE)))
```

Check that we got no errors (`TRUE` means no error).
```{r quid.est.happening.too.too}
lapply(vout.parents, function(x) sapply(x, function(x)
    ! inherits(x, "try-error")))
```
Oops!  No standard errors for CS 2015.

## Offspring

We have six analyses to do here, one for each site-year combination.
```{r reaster.offspring, cache=TRUE, cache.extra=key.data}
years <- with(data.primary[[1]], year[cohort == "field"]) |> sort() |> unique()
names(years) <- years
years
rout.offspring <- lapply(data.primary, function(x) lapply(years, function(y) {
    subdat <- subset(x, year == y & cohort == "field")
    subdat <- droplevels(subdat)
    redata <- reshape(subdat, varying = list(vars), direction = "long",
        timevar = "varb", times = as.factor(vars), v.names = "resp")
    redata <- transform(redata,
        fit = as.numeric(grepl("totalseeds", as.character(varb))),
        root = 1)
    reaster(resp ~ fit + varb,
        list(parental = ~ 0 + fit:grandpaternalID, block = ~ 0 + fit:block),
        pred, fam, varb, id, root, data = redata)
    }))
```
Summaries.
```{r summary.reaster.offspring, cache=TRUE, depends="reaster.offspring"}
sout.offspring <- lapply(rout.offspring, function(x) lapply(x, summary))
```
Estimates of variance components.
```{r quid.est.happening.too.too.too}
lapply(sout.offspring, function(x) lapply(x, function(x) x$nu[ , "Estimate"]))
```

Check that variance-covariance calculation also works.
```{r vcov.reaster.offspring, cache=TRUE, depends="reaster.offspring"}
vout.offspring <- lapply(rout.offspring, function(x)
    lapply(x, function(x) try(vcov(x, standard.deviation = FALSE,
        re.too = TRUE, complete = TRUE), silent = TRUE)))
```

Check that we got no errors (`TRUE` means no error).
```{r quid.est.happening.too.too.off}
lapply(vout.offspring, function(x) sapply(x, function(x)
    ! inherits(x, "try-error")))
```

