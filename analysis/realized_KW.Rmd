---
title: "Estimates of Realized response to selection for @kulbaba-et-al"
author:
  - "Charles J. Geyer^[School of Statistics, University of Minnesota, geyer@umn.edu, https://orcid.org/0000-0003-1471-1703]"
  - "Mason W. Kulbaba^[Department of Mathematics and Science, Our Lady of the Lake University, mkulbaba@ollusa.edu, https://orcid.org/0000-0003-0619-7089]"
  - "Seema N. Sheth^[Department of Plant and Microbial Biology, North Carolina State University, ssheth3@ncsu.edu, https://orcid.org/0000-0001-8284-7608]"
  - "Rachel E. Pain^[Ecology, Evolution and Behavior Graduate Program, University of Minnesota, repain@umn.edu]"
  - "Vincent M. Eckhart^[Department of Biology, Grinnell College, eckhart@grinnell.edu]"
  - "Ruth G. Shaw^[Department of Ecology, Evolution and Behavior, University of Minnesota, shawx016@umn.edu, https://orcid.org/0000-0001-5980-9291]"
date: "August 19, 2022"
output:
  bookdown::pdf_document2:
    extra_dependencies: "amscd"
    number_sections: true
    toc: true
    toc_depth: 3
linkcolor: blue
urlcolor: blue
bibliography: foo.bib
csl: journal-of-the-royal-statistical-society.csl
link-citations: true
---

# Abstract

This work builds on @kulbaba-et-al and the correction to it [@zenodo]
to obtain estimates of the realized response to natural selection.
Those articles
presented estimates of mean fitness and additive genetic variance for fitness
we obtained for three populations of *Chamaecrista fasciculata*,
each grown in its home location in three years via aster analyses of records of components of fitness for a pedigreed set of individuals.
Here, we consider the realized change in mean fitness from one generation to the next, for comparison with the prediction from Fisher's
Fundamental Theorem of Natural Selection (FFTNS).
We follow @mean-fitness,
which divides change in mean fitness into three parts:
that due to change in genetic composition described by FFTNS,
that due to change in genetic composition not described by FFTNS, and
that due to change in environment.
Here, we obtain estimates of a) mean fitness of the pedigreed parental populations before selection (previously presented in @kulbaba-et-al and the
Correction); b) mean fitness of the pedigreed parental population after selection (i.e. accounting for the change in representation of the families
reflected in differential seed production); and mean fitness of the offspring of the pedigreed sets
(i.e. the outcome of natural selection on the parental
generation when grown in the same sites in the following year).

We also obtain standard errors of our estimates.

# License

This work is licensed under a Creative Commons
CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
(https://creativecommons.org/publicdomain/zero/1.0/).

# R

 * The version of R used to make this document is `r getRversion()`.

 * The version of the `rmarkdown` package used to make this document is
   `r packageVersion("rmarkdown")`.

 * The version of the `bookdown` package used to make this document is
   `r packageVersion("bookdown")`.

 * The version of the `aster` package used to make this document is
   `r packageVersion("aster")`.

 * The version of the `numDeriv` package used to make this document is
   `r packageVersion("numDeriv")`.

As far as we know, any fairly recent version of R or these packages
will do for processing this Rmarkdown document.  We are not using
cutting edge features.

Attach packages.
```{r package}
library("aster")
library("numDeriv")
```

Need at least version 1.2 of R package `aster` for R generic function `vcov`
to work on results of calls to R functions `aster` and `reaster`.
```{r aster-version}
stopifnot(compareVersion(as.character(packageVersion("aster")), "1.2") >= 0)
```

```{r checkerrors, echo=FALSE}
# make all code chunks after this one have option error=TRUE
knitr::opts_chunk$set(error=TRUE)
```

# Data

For the analyses in @kulbaba-et-al and @zenodo the data files are
```
GCdat.csv
KWdat.csv
csdat.csv
```
for 

 * Grey Cloud Dunes Scientific and Natural Area

 * Kellogg-Weaver Dunes, also called McCarthy Lake, and

 * Conard Environmental Research Area (CERA),

respectively.  For more details @kulbaba-et-al.

These data files were downloaded from the GitHub repository
https://github.com/mason-kulbaba/adaptive-capacity which
contains the code and data for the analysis of the original paper.
So we are using the same data but doing a different analysis.

For this document the data files are
```
KWdat.csv
KW_2015_planting_data.csv
```
The former is the same data used by @kulbaba-et-al and @zenodo,
and the latter contains pedigree information we need to match up
offspring with parents and grandparents.

# Introduction

We do aster (@aster2, @reaster) analyses for an aster model with graph
$$
\begin{CD}
  1 @>\text{Ber}>> \texttt{Germ}
  @>\text{Ber}>> \texttt{flw}
  @>\text{Poi}>> \texttt{total.pods}
  @>\text{samp}>> \texttt{total.pods.collected}
  @>\text{Poi}>> \texttt{totalseeds}
\end{CD}
$$
where the variables are

 * `Germ` is germination indicator (0 = no, 1 = yes), conditionally Bernoulli.

 * `flw` is survival to flowering (0 = no, 1 = yes),
    conditionally Bernoulli.

 * `total.pods` is total number of pods produced,
   conditionally Poisson.

 * `total.pods.collected` is number of pods collected,
   conditionally Bernoulli (i.e. each pod may be collected or not).  The arrow leading to this node
   is a subsampling arrow.  The number of pods collected is
   a random sample of the pods produced.

 * `totalseeds` is total number of seeds counted from collected pods,
   conditionally Poisson.

As always with aster models, the name of the distribution for an arrow
is the name of the conditional distribution of the successor variable
given the predecessor variable.

Set graphical model description in R.
```{r graph}
vars <- c("Germ", "flw", "total.pods", "total.pods.collected", "totalseeds")
pred <- c(0, 1, 2, 3, 4)
fam <- c(1, 1, 2, 1, 2)
```

# Example Analysis

## Determine Data to Analyze

We start by doing one example, but we do it in such a way that code
can be reused for all analyses.  The following two variables determine
(entirely) the analysis to be done.
```{r mydata.myyear}
mydata <- "KWdat.csv"
myyear <- 2015
```
We also need to specify the year of the corresponding set of offspring.

```{r myyearf}
myyearf <- myyear + 1
```

## Read Data

Read in data.
```{r read}
dat <- read.csv(mydata)
```

## Remove Maternal ID Zero

Parental ID Zero is "unknown" and hence should be removed
from these analyses.
```{r remove}
dat <- subset(dat, maternalID != 0)
```

## Make Factor Variables

Show types of variables.
```{r types}
sapply(dat, class)
```
Some of these variables need to be `factor`.
```{r factor}
dat <- transform(dat,
    maternalID = as.factor(maternalID),
    paternalID = as.factor(paternalID),
    block = as.factor(block))
```

## Fix Data

Check subsampling is correct, i.e. that the number of pods sampled from a given plant is not greater than the total number of pods it was recorded to
have produced.
```{r oopsie}
oopsie <- with(dat, total.pods.collected > total.pods)
```
The following should say `FALSE`.
```{r oopsie.show}
any(oopsie)
```

For this example, there is a problem to fix.
```{r subsamp.too}
if (any(oopsie))
    dat[oopsie, ]
```

So this data error has to be corrected: we assume
`total.pods` is correct and equal to `total.pods.collected`
for these rows of the data.
```{r subsamp.fix}
if (any(oopsie))
    dat[oopsie, "total.pods.collected"] <- dat[oopsie, "total.pods"]
```

## Subset Data for pedigreed cohort

Subset the data to get one part we want to analyze separately.
```{r data.too}
subdat <- subset(dat, year == myyear & cohort == "greenhouse")
with(subdat, length(unique(paternalID)))
```

And another part we want to analyze in the same way.
```{r data.too.next}
subdatnext <- subset(dat, year == myyearf & cohort == "greenhouse")
with(subdatnext, length(unique(paternalID)))
```

## Remove Paternal ID Zero

Parental ID Zero is "unknown" and hence should be removed
from these analyses.
```{r remove2}
subdat <- subset(subdat, paternalID != 0)
subdatnext <- subset(subdatnext, paternalID != 0)
```


Show that we did the subset correctly.
```{r data.too.show}
unique(subdat$year)
unique(subdatnext$year)
```

## Subset Data for offspring cohort (field)

Now for offspring data.
Subset the data to get one part we want to analyze separately.
Other parts are analyzed in the same way.
Divide into year-specific files.
```{r dataf.too}
subdatfield <- subset(dat, year == myyearf & cohort == "field")
```

Show that we did the subset correctly.
```{r dataf.too.show}
unique(subdatfield$year)
```
Drop unused levels.
```{r data.too.too}
subdat <- droplevels(subdat)
subdatnext <- droplevels(subdatnext)
subdatfield <- droplevels(subdatfield)
```

## Find Grandfathers

Now we have to look up grandfathers of the offspring generation.
To do this we have to look up data in another file
and use R function `match`.
```{r findGDs2016}
plantingdat2015 <- read.csv("KW_2015_planting_data.csv")
names(plantingdat2015)
idx <- match(subdatfield$position, plantingdat2015$position)
length(idx)
head(idx)
```
Every plant is in a certain row and position within row.
We combine these into one key.
```{r findGDs2016.too}
pos_row <- with(subdatfield, paste(position,row,sep="_"))
head(pos_row)
pos_row_planting2015 <- with(plantingdat2015, paste(position,row,sep="_"))
idx <- match(pos_row, pos_row_planting2015)
```
Now R vector `idx` tells us which individuals in R data frame `subdatfield`
correspond to which individuals in R dataframe `plantingdat2015`, that is,
```{r findGDs2016.too.show}
identical(pos_row, pos_row_planting2015[idx])
```
The fact that there are no `NA` values in `idx` means every individual in
data frame `subdatfield` has been found in dataframe `plantingdat2015`.
```{r findGDs2016.too.show.too}
all(! is.na(idx))
```

Now we do the find the dams of these individuals.

```{r findGDs2016.too.too}
matloc <- with(plantingdat2015,
    paste(maternalposition[idx], maternalrow[idx], sep="_"))
matlocsubdat <- with(subdat, paste(position, row, sep="_"))
idx2 <- match(matloc, matlocsubdat)
all(! is.na(idx2))
length(idx2) == nrow(subdatfield)
```
So now `idx2` gives the index in `subdat` of the mother of the individual
in the corresponding position in `subdatfield`.  So the following adds
a maternal grandfather variable to R data frame `subdatfield`.
```{r findGDs2016.too.too.too}
subdatfield <- transform(subdatfield, grandfather=subdat$paternalID[idx2])

names(subdatfield)
head(subdatfield)
with(subdatfield, length(unique(grandfather)))
```

## Reshape Data

Reshape data the way R function `aster` wants it.
```{r reshape}
redata <- reshape(subdat, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
redataf <- reshape(subdatfield, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
redatanext <- reshape(subdatnext, varying = list(vars), direction = "long",
    timevar = "varb", times = as.factor(vars), v.names = "resp")
```

Add indicator variable `fit` to indicate "fitness" nodes (in these data
just one node).  Also add `root` (in these data always equal to 1).
```{r fit}
redata <- transform(redata,
    fit = as.numeric(grepl("totalseeds", as.character(varb))),
    root = 1)
redataf <- transform(redataf,
    fit = as.numeric(grepl("totalseeds", as.character(varb))),
    root = 1)
redatanext <- transform(redatanext,
    fit = as.numeric(grepl("totalseeds", as.character(varb))),
    root = 1)
```

## Random Effect Aster Model

In our preliminary analyses of the pedigreed cohort, produced by hand-pollinations in the greenhouse, we modeled sire and dam effects separately and found their components of variance to be comparable in magnitude. This is
evidence that there are negligible contributions of dominance and maternal effects to resemblance of sibs. It is thus valid to estimate a single common
variance for the nuclear genetic contributions of sires and of dams to offspring fitness. 
In order to have the same variance for the random effects for sires and dams we do the following.
```{r random.effect}
modmat.sire <- model.matrix(~ 0 + fit:paternalID, redata)
modmat.dam <- model.matrix(~ 0 + fit:maternalID, redata)
head(colnames(modmat.sire))
head(colnames(modmat.dam))
modmat.siredam <- cbind(modmat.sire, modmat.dam)
```

```{r key.gc, echo=FALSE}
key <- tools::md5sum(mydata)
```

Then we can fit the model.
```{r random.effect.too, cache=TRUE, cache.extra=key}
rout <- reaster(resp ~ fit + varb,
    list(parental=~0 + modmat.siredam, block = ~ 0 + fit:block),
    pred, fam, varb, id, root, data = redata)
```
And show the results.
```{r random.effect.show, cache=TRUE, dependson="random.effect.too"}
summary(rout)
```

## Another Random Effect Aster Model

```{r random.effect.next.modmat}
modmat.sire.next <- model.matrix(~ 0 + fit:paternalID, redatanext)
modmat.dam.next <- model.matrix(~ 0 + fit:maternalID, redatanext)
modmat.siredam.next <- cbind(modmat.sire.next, modmat.dam.next)
```

```{r random.effect.next, cache=TRUE, cache.extra=key}
rout.next <- reaster(resp ~ fit + varb,
    list(parental=~0 + modmat.siredam.next, block = ~ 0 + fit:block),
    pred, fam, varb, id, root, data = redatanext)
```
And show the results.
```{r random.effect.show.next, cache=TRUE, dependson="random.effect.next"}
summary(rout.next)
```

## Random Effect Aster Model for offspring generation ('field')

### Grandfather Effects

The offspring generation arose via open pollination of the pedigreed generation. 
For this reason, we do not know paternity of individuals in this generation.
We focus on
mean fitnesses for families descending from individual sires in the set
of crosses that produced the pedigreed generation.
```{r random.effect.grandfather, cache=TRUE, cache.extra=key}
routf.granddad <- reaster(resp ~ fit + varb,
    list(parental = ~ 0 + fit:grandfather, block = ~ 0 + fit:block),
    pred, fam, varb, id, root, data = redataf)
```
```{r random.effect.grandfather.summary}
summary(routf.granddad)
```

### Maternal Effects

For interest's sake, we also carry out random effects analysis 
with maternal plant in the pedigreed generation as the random factor.
We do not use this analysis in further analysis.  (Rather, we use
the preceding one with grandsire effects.)
```{r random.effect.dam, cache=TRUE, cache.extra=key}
routf.mom <- reaster(resp ~ fit + varb,
    list(parental = ~ 0 + fit:maternalID, block = ~ 0 + fit:block),
    pred, fam, varb, id, root, data = redataf)
```
```{r random.effect.dam.summary}
summary(routf.mom)
```

# Mapping Sire and Grandsire Effects to Mean Values

We follow Section 9 of @zenodo *mutatis mutandis*.  The main changes are

 * here we will have a vectorizing function that simultaneously does
   all expected fitness values for all individuals and

 * here we will calculate derivatives (Jacobian matrix) as well as function
   values.

```{r map}
map <- function(rout, is.subsamp, include.random) {
    stopifnot(inherits(rout, "reaster"))
    stopifnot(is.logical(is.subsamp))
    stopifnot(is.logical(include.random))
    aout <- rout$obj
    stopifnot(inherits(aout, "aster"))
    nnode <- ncol(aout$x)
    if(nnode != length(is.subsamp))
        stop("length(is.subsamp) not the number of nodes in the aster graph")
    fixed <- rout$fixed
    random <- rout$random
    alpha <- rout$alpha
    bee <- rout$b
    if(length(bee) != length(include.random))
        stop("length(include.random) not the number of random effects",
            " in the aster model")
    # fake object of class aster
    fake.out <- aout
    fake.beta <- c(alpha, bee[include.random])
    modmat.random <- Reduce(cbind, random)
    stopifnot(ncol(modmat.random) == length(bee))
    modmat.random <- modmat.random[ , include.random, drop = FALSE] 
    fake.modmat <- cbind(fixed, modmat.random)
    # now have to deal with objects of class aster (as opposed to reaster)
    # think model matrices are three-way arrays.
    stopifnot(prod(dim(aout$modmat)[1:2]) == nrow(fake.modmat))
    fake.modmat <- array(as.vector(fake.modmat),
        dim = c(dim(aout$modmat)[1:2], ncol(fake.modmat)))
    fake.out$modmat <- fake.modmat
    fake.out$coefficients <- fake.beta
    pout <- predict(fake.out, model.type = "conditional",
        is.always.parameter = TRUE, gradient = TRUE)
}



#        xi <- predict(aout, newcoef = alpha,
#            model.type = "conditional", is.always.parameter = TRUE)
#        xi <- matrix(xi, ncol = nnode)
#        # always use drop = FALSE unless you are sure you don't want that
#        # here if we omit drop = FALSE and there is only one non-subsampling
#        # node, the code will break (apply will give an error)
#        xi <- xi[ , ! is.subsamp, drop = FALSE]
#        mu <- apply(xi, 1, prod)
#        # mu is unconditional mean values for model without subsampling
#        # in this application all components mu are the same because no
#        # covariates except varb, so just return only one
#        mu[1]
```

Test.
```{r map.test}
foo <- map(rout, grepl("collected", vars), grepl("paternal", names(rout$b)))
names(foo)
```


# References

